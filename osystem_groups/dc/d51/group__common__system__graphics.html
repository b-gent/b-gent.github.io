<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ScummVM API documentation: Graphics</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../scummvm_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ScummVM API documentation
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dc/d51/group__common__system__graphics.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Graphics<div class="ingroups"><a class="el" href="../../db/d78/group__common.html">Common API</a> &raquo; <a class="el" href="../../d1/d0c/group__common__system.html">OSystem</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The way graphics work in the <a class="el" href="../../d2/d38/class_o_system.html">OSystem</a> class is meant to make it possible for game frontends to implement everything they need in an efficient manner. The downside of this is that it may be rather complicated for backend authors to fully understand and implement the semantics of the <a class="el" href="../../d2/d38/class_o_system.html">OSystem</a> interface.</p>
<p>The graphics visible to the user in the end are actually composed of three layers: the game graphics, the overlay graphics, and the mouse.</p>
<p>First, there are the game graphics. The methods in this section deal with them exclusively. In particular, the size of the game graphics is defined by a call to <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga8574a1d7b9925c6573c65e45b46c1ada">initSize()</a>, and <a class="el" href="../../dc/d51/group__common__system__graphics.html#gaafd1ca71d829f306b4b6d4cdaedcbcf7">copyRectToScreen()</a> blits the data in the current pixel format into the game layer. Let W and H denote the width and height of the game graphics.</p>
<p>Before the user sees these graphics, the backend may apply some transformations to it. For example, they may be scaled to better fit the visible screen or aspect ratio correction may be performed (see kFeatureAspectRatioCorrection). As a result of this, a pixel of the game graphics may occupy a region bigger than a single pixel on the screen. p_w and p_h are defined to be the width and, respectively, height of a game pixel on the screen.</p>
<p>In addition, there is a vertical "shake offset" (as defined by setShakePos) that is used in some games to provide a shaking effect. Note that shaking is applied to all three layers, i.e. also to the overlay and the mouse. The shake offset is denoted by S.</p>
<p>Putting this together, a pixel (x,y) of the game graphics is transformed to a rectangle of height p_h and width p_w appearing at position (p_w * x, p_hw * (y + S)) on the real screen. In addition, a backend may choose to offset everything, e.g. to center the graphics on the screen.</p>
<p>The next layer is the overlay. It is composed over the game graphics. Historically, the overlay size had always been a multiple of the game resolution. For example, if the game resolution was 320x200 and the user selected a 2x scaler and did not enable aspect ratio correction, it had a size of 640x400. An exception was the aspect ratio correction, which did allow for non multiples of the vertical resolution of the game screen. Currently, the overlay size does not need to have any relation to the game resolution though, for example the overlay resolution might be the same as the physical screen resolution. The overlay is forced to a 16 bpp mode right now.</p>
<p>Finally, there is the mouse layer. This layer does not have to actually exist within the backend &ndash; it all depends on how a backend chooses to implement mouse cursors. However, in the default SDL backend, it really is a separate layer. The mouse can have a palette of its own, if the backend supports it.</p>
<p>Graphics do not need to be thread-safe and in fact most/all backends using OpenGL are not. So do <em>not</em> try to call any of these functions from a timer and/or audio callback (like readBuffer of AudioStreams). </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc1/struct_o_system_1_1_graphics_mode.html">OSystem::GraphicsMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae815218bc6505c71d60e2f3fb5674b60"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gae815218bc6505c71d60e2f3fb5674b60">OSystem::GfxModeFlags</a> { <a class="el" href="../../dc/d51/group__common__system__graphics.html#ggae815218bc6505c71d60e2f3fb5674b60a6b33e2bfa5cf0d7f0e190a523db0db95">OSystem::kGfxModeNoFlags</a> = 0, 
<a class="el" href="../../dc/d51/group__common__system__graphics.html#ggae815218bc6505c71d60e2f3fb5674b60a701062893ba76d45d45d1dbd2ae128a1">OSystem::kGfxModeRender3d</a> = (1 &lt;&lt; 0)
 }</td></tr>
<tr class="separator:gae815218bc6505c71d60e2f3fb5674b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fc8170ee88c60da61b98df8ceb159c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga48fc8170ee88c60da61b98df8ceb159c">OSystem::TransactionError</a> { <br />
&#160;&#160;<a class="el" href="../../dc/d51/group__common__system__graphics.html#gga48fc8170ee88c60da61b98df8ceb159ca66fa9aad355638a74399dc4c3bfb8ac4">OSystem::kTransactionSuccess</a> = 0, 
<a class="el" href="../../dc/d51/group__common__system__graphics.html#gga48fc8170ee88c60da61b98df8ceb159ca63716f7d521a43fbe27c50832eb00dce">OSystem::kTransactionAspectRatioFailed</a> = (1 &lt;&lt; 0), 
<a class="el" href="../../dc/d51/group__common__system__graphics.html#gga48fc8170ee88c60da61b98df8ceb159caa4b9c084a757f5b203ca709a0f614752">OSystem::kTransactionFullscreenFailed</a> = (1 &lt;&lt; 1), 
<a class="el" href="../../dc/d51/group__common__system__graphics.html#gga48fc8170ee88c60da61b98df8ceb159ca28799b1e6ddcbb2f2d0cc34122bef264">OSystem::kTransactionModeSwitchFailed</a> = (1 &lt;&lt; 2), 
<br />
&#160;&#160;<a class="el" href="../../dc/d51/group__common__system__graphics.html#gga48fc8170ee88c60da61b98df8ceb159cac8a04ee3b1bef026790377fe79e79839">OSystem::kTransactionSizeChangeFailed</a> = (1 &lt;&lt; 3), 
<a class="el" href="../../dc/d51/group__common__system__graphics.html#gga48fc8170ee88c60da61b98df8ceb159ca7a40f191e89d29236bcea4c10efc003a">OSystem::kTransactionFormatNotSupported</a> = (1 &lt;&lt; 4), 
<a class="el" href="../../dc/d51/group__common__system__graphics.html#gga48fc8170ee88c60da61b98df8ceb159ca6d79fe85fb37a1856e950cb2c4f155b1">OSystem::kTransactionFilteringFailed</a> = (1 &lt;&lt; 5), 
<a class="el" href="../../dc/d51/group__common__system__graphics.html#gga48fc8170ee88c60da61b98df8ceb159ca00239d2e06d1e7f765ea82b38e61df95">OSystem::kTransactionStretchModeSwitchFailed</a> = (1 &lt;&lt; 6)
<br />
 }</td></tr>
<tr class="separator:ga48fc8170ee88c60da61b98df8ceb159c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0dc1fa028b649304870d3b1c3085602c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../dd/dc1/struct_o_system_1_1_graphics_mode.html">GraphicsMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga0dc1fa028b649304870d3b1c3085602c">OSystem::getSupportedGraphicsModes</a> () const</td></tr>
<tr class="separator:ga0dc1fa028b649304870d3b1c3085602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa94ee82b01397e91fd6c30fe35069df"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gafa94ee82b01397e91fd6c30fe35069df">OSystem::getDefaultGraphicsMode</a> () const</td></tr>
<tr class="separator:gafa94ee82b01397e91fd6c30fe35069df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9aacb79763a8b06d415d83e549b6f1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga7d9aacb79763a8b06d415d83e549b6f1">OSystem::setGraphicsMode</a> (int mode, uint flags=<a class="el" href="../../dc/d51/group__common__system__graphics.html#ggae815218bc6505c71d60e2f3fb5674b60a6b33e2bfa5cf0d7f0e190a523db0db95">kGfxModeNoFlags</a>)</td></tr>
<tr class="separator:ga7d9aacb79763a8b06d415d83e549b6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade71cd6f36f9c795ffc738f1dd5f1ff1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gade71cd6f36f9c795ffc738f1dd5f1ff1">OSystem::setGraphicsMode</a> (const char *name)</td></tr>
<tr class="separator:gade71cd6f36f9c795ffc738f1dd5f1ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac9f23d6481dcab24dc0ced883d8674"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga1ac9f23d6481dcab24dc0ced883d8674">OSystem::getGraphicsMode</a> () const</td></tr>
<tr class="separator:ga1ac9f23d6481dcab24dc0ced883d8674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a1e6c09495e5d71d6b911f30a47d0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga80a1e6c09495e5d71d6b911f30a47d0d">OSystem::resetGraphicsScale</a> ()</td></tr>
<tr class="separator:ga80a1e6c09495e5d71d6b911f30a47d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f7c6fd2ef7072e92ce6d087479f3c8"><td class="memItemLeft" align="right" valign="top"><a id="ga15f7c6fd2ef7072e92ce6d087479f3c8"></a>
Graphics::PixelFormat&#160;</td><td class="memItemRight" valign="bottom"><b>OSystem::getScreenFormat</b> () const</td></tr>
<tr class="separator:ga15f7c6fd2ef7072e92ce6d087479f3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214571d455baa7a6c84354bf1e21280f"><td class="memItemLeft" align="right" valign="top"><a id="ga214571d455baa7a6c84354bf1e21280f"></a>
Common::List&lt; Graphics::PixelFormat &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OSystem::getSupportedFormats</b> () const</td></tr>
<tr class="separator:ga214571d455baa7a6c84354bf1e21280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f80c389e7d5aa14c3b76a29842b7fc"><td class="memItemLeft" align="right" valign="top">virtual Common::Array&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gab8f80c389e7d5aa14c3b76a29842b7fc">OSystem::getSupportedAntiAliasingLevels</a> () const</td></tr>
<tr class="separator:gab8f80c389e7d5aa14c3b76a29842b7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ed216d0fa410c8a97f4c96adb87721"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../dd/dc1/struct_o_system_1_1_graphics_mode.html">GraphicsMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga84ed216d0fa410c8a97f4c96adb87721">OSystem::getSupportedShaders</a> () const</td></tr>
<tr class="separator:ga84ed216d0fa410c8a97f4c96adb87721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9b2ad0d7a10c74bdc57e0732471b3a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gadf9b2ad0d7a10c74bdc57e0732471b3a">OSystem::getDefaultShader</a> () const</td></tr>
<tr class="separator:gadf9b2ad0d7a10c74bdc57e0732471b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4a7110c7ac5e91efb8f9ccf918e6c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga3f4a7110c7ac5e91efb8f9ccf918e6c9">OSystem::setShader</a> (int id)</td></tr>
<tr class="separator:ga3f4a7110c7ac5e91efb8f9ccf918e6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64e59b53635de89a69d8f28a91265039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga64e59b53635de89a69d8f28a91265039">OSystem::setShader</a> (const char *name)</td></tr>
<tr class="separator:ga64e59b53635de89a69d8f28a91265039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb60de0651a38b168cf10d7be7f0f12a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gabb60de0651a38b168cf10d7be7f0f12a">OSystem::getShader</a> () const</td></tr>
<tr class="separator:gabb60de0651a38b168cf10d7be7f0f12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ff83a077aea8010365cadd71e069ff"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../dd/dc1/struct_o_system_1_1_graphics_mode.html">GraphicsMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga26ff83a077aea8010365cadd71e069ff">OSystem::getSupportedStretchModes</a> () const</td></tr>
<tr class="separator:ga26ff83a077aea8010365cadd71e069ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fb4d311447dbb3275fd749c8a4a872"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga30fb4d311447dbb3275fd749c8a4a872">OSystem::getDefaultStretchMode</a> () const</td></tr>
<tr class="separator:ga30fb4d311447dbb3275fd749c8a4a872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b29d7de9ef8eca12f102c75b71aeb5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gaf5b29d7de9ef8eca12f102c75b71aeb5">OSystem::setStretchMode</a> (int mode)</td></tr>
<tr class="separator:gaf5b29d7de9ef8eca12f102c75b71aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc340ea066fa6e90c29389ba30d63ac1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gafc340ea066fa6e90c29389ba30d63ac1">OSystem::setStretchMode</a> (const char *name)</td></tr>
<tr class="separator:gafc340ea066fa6e90c29389ba30d63ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2947969d0e6bd53e2861504085f7dd8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gac2947969d0e6bd53e2861504085f7dd8">OSystem::getStretchMode</a> () const</td></tr>
<tr class="separator:gac2947969d0e6bd53e2861504085f7dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8574a1d7b9925c6573c65e45b46c1ada"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga8574a1d7b9925c6573c65e45b46c1ada">OSystem::initSize</a> (uint width, uint height, const Graphics::PixelFormat *format=nullptr)=0</td></tr>
<tr class="separator:ga8574a1d7b9925c6573c65e45b46c1ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d50cd90f90dc0d24cdfdfbc9af7409b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga0d50cd90f90dc0d24cdfdfbc9af7409b">OSystem::initSizeHint</a> (const Graphics::ModeList &amp;modes)</td></tr>
<tr class="separator:ga0d50cd90f90dc0d24cdfdfbc9af7409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b0fa3319a08ccde3a7e59efede348b0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga9b0fa3319a08ccde3a7e59efede348b0">OSystem::getScreenChangeID</a> () const</td></tr>
<tr class="separator:ga9b0fa3319a08ccde3a7e59efede348b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e53c3c0d13ad5cd7b20f3ab42e71651"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga5e53c3c0d13ad5cd7b20f3ab42e71651">OSystem::beginGFXTransaction</a> ()</td></tr>
<tr class="separator:ga5e53c3c0d13ad5cd7b20f3ab42e71651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ac3bef878805f47afea75769010e52"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga48fc8170ee88c60da61b98df8ceb159c">TransactionError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga01ac3bef878805f47afea75769010e52">OSystem::endGFXTransaction</a> ()</td></tr>
<tr class="separator:ga01ac3bef878805f47afea75769010e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2be76e9ae3a95e4ece3732588e0ac3"><td class="memItemLeft" align="right" valign="top">virtual int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga1e2be76e9ae3a95e4ece3732588e0ac3">OSystem::getHeight</a> ()=0</td></tr>
<tr class="separator:ga1e2be76e9ae3a95e4ece3732588e0ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ffdad22d90db55c78774c75cbac711"><td class="memItemLeft" align="right" valign="top">virtual int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga09ffdad22d90db55c78774c75cbac711">OSystem::getWidth</a> ()=0</td></tr>
<tr class="separator:ga09ffdad22d90db55c78774c75cbac711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5b166e5de40e49ce075fa3f2509eaa"><td class="memItemLeft" align="right" valign="top">virtual PaletteManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga5a5b166e5de40e49ce075fa3f2509eaa">OSystem::getPaletteManager</a> ()=0</td></tr>
<tr class="separator:ga5a5b166e5de40e49ce075fa3f2509eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd1ca71d829f306b4b6d4cdaedcbcf7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gaafd1ca71d829f306b4b6d4cdaedcbcf7">OSystem::copyRectToScreen</a> (const void *buf, int pitch, int x, int y, int w, int h)=0</td></tr>
<tr class="separator:gaafd1ca71d829f306b4b6d4cdaedcbcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a4f05596bd55c887e35a34937939c5"><td class="memItemLeft" align="right" valign="top">virtual Graphics::Surface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga56a4f05596bd55c887e35a34937939c5">OSystem::lockScreen</a> ()=0</td></tr>
<tr class="separator:ga56a4f05596bd55c887e35a34937939c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab87138a721368bed7abde76c0f24c880"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gab87138a721368bed7abde76c0f24c880">OSystem::unlockScreen</a> ()=0</td></tr>
<tr class="separator:gab87138a721368bed7abde76c0f24c880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12df877f26c4db662aece81be9bf833"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gaf12df877f26c4db662aece81be9bf833">OSystem::fillScreen</a> (uint32 col)=0</td></tr>
<tr class="separator:gaf12df877f26c4db662aece81be9bf833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6983105f21ef8bdf828a51e4cec4cfe8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga6983105f21ef8bdf828a51e4cec4cfe8">OSystem::updateScreen</a> ()=0</td></tr>
<tr class="separator:ga6983105f21ef8bdf828a51e4cec4cfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f9a92117c13ae543fcaa6769a31614d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga2f9a92117c13ae543fcaa6769a31614d">OSystem::setShakePos</a> (int shakeXOffset, int shakeYOffset)=0</td></tr>
<tr class="separator:ga2f9a92117c13ae543fcaa6769a31614d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga337901711715fd99610be213a9e0dab0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga337901711715fd99610be213a9e0dab0">OSystem::setFocusRectangle</a> (const Common::Rect &amp;rect)</td></tr>
<tr class="separator:ga337901711715fd99610be213a9e0dab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6676d67905f65114a3e95f6b45227b67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga6676d67905f65114a3e95f6b45227b67">OSystem::clearFocusRectangle</a> ()</td></tr>
<tr class="separator:ga6676d67905f65114a3e95f6b45227b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac31a87a460c151f736111749fba629f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d51/group__common__system__graphics.html#gac31a87a460c151f736111749fba629f2">OSystem::saveScreenshot</a> ()</td></tr>
<tr class="separator:gac31a87a460c151f736111749fba629f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae815218bc6505c71d60e2f3fb5674b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae815218bc6505c71d60e2f3fb5674b60">&#9670;&nbsp;</a></span>GfxModeFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../dc/d51/group__common__system__graphics.html#gae815218bc6505c71d60e2f3fb5674b60">OSystem::GfxModeFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae815218bc6505c71d60e2f3fb5674b60a6b33e2bfa5cf0d7f0e190a523db0db95"></a>kGfxModeNoFlags&#160;</td><td class="fielddoc"><p>No flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae815218bc6505c71d60e2f3fb5674b60a701062893ba76d45d45d1dbd2ae128a1"></a>kGfxModeRender3d&#160;</td><td class="fielddoc"><p>Indicate 3D hardware-accelerated in-game GFX. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga48fc8170ee88c60da61b98df8ceb159c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48fc8170ee88c60da61b98df8ceb159c">&#9670;&nbsp;</a></span>TransactionError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga48fc8170ee88c60da61b98df8ceb159c">OSystem::TransactionError</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type can save the different errors which can happen while changing GFX config values inside GFX transactions.</p>
<p>endGFXTransaction returns an ORed combination of the '*Failed' values if any problem occurs. It returns '0' on success.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga01ac3bef878805f47afea75769010e52">endGFXTransaction</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga48fc8170ee88c60da61b98df8ceb159ca66fa9aad355638a74399dc4c3bfb8ac4"></a>kTransactionSuccess&#160;</td><td class="fielddoc"><p>Everything fine (use EQUAL check for this one!) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48fc8170ee88c60da61b98df8ceb159ca63716f7d521a43fbe27c50832eb00dce"></a>kTransactionAspectRatioFailed&#160;</td><td class="fielddoc"><p>Failed switching aspect ratio correction mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48fc8170ee88c60da61b98df8ceb159caa4b9c084a757f5b203ca709a0f614752"></a>kTransactionFullscreenFailed&#160;</td><td class="fielddoc"><p>Failed switching fullscreen mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48fc8170ee88c60da61b98df8ceb159ca28799b1e6ddcbb2f2d0cc34122bef264"></a>kTransactionModeSwitchFailed&#160;</td><td class="fielddoc"><p>Failed switching the GFX graphics mode (setGraphicsMode) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48fc8170ee88c60da61b98df8ceb159cac8a04ee3b1bef026790377fe79e79839"></a>kTransactionSizeChangeFailed&#160;</td><td class="fielddoc"><p>Failed switching the screen dimensions (initSize) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48fc8170ee88c60da61b98df8ceb159ca7a40f191e89d29236bcea4c10efc003a"></a>kTransactionFormatNotSupported&#160;</td><td class="fielddoc"><p>Failed setting the color format </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48fc8170ee88c60da61b98df8ceb159ca6d79fe85fb37a1856e950cb2c4f155b1"></a>kTransactionFilteringFailed&#160;</td><td class="fielddoc"><p>Failed setting the filtering mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48fc8170ee88c60da61b98df8ceb159ca00239d2e06d1e7f765ea82b38e61df95"></a>kTransactionStretchModeSwitchFailed&#160;</td><td class="fielddoc"><p>Failed setting the stretch mode </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0dc1fa028b649304870d3b1c3085602c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc1fa028b649304870d3b1c3085602c">&#9670;&nbsp;</a></span>getSupportedGraphicsModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="../../dd/dc1/struct_o_system_1_1_graphics_mode.html">GraphicsMode</a>* OSystem::getSupportedGraphicsModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a list of all graphics modes supported by this backend.</p>
<p>This can be both video modes as well as graphic filters/scalers. It is completely up to the backend maintainer to decide what is appropriate here and what not. The list is terminated by an all-zero entry.</p>
<dl class="section return"><dt>Returns</dt><dd>List of supported graphics modes. </dd></dl>

</div>
</div>
<a id="gafa94ee82b01397e91fd6c30fe35069df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa94ee82b01397e91fd6c30fe35069df">&#9670;&nbsp;</a></span>getDefaultGraphicsMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getDefaultGraphicsMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ID of the 'default' graphics mode. What exactly this means is up to the backend. This mode is set by the client code when no user overrides are present (i.e. if no custom graphics mode is selected using the command line or a config file).</p>
<dl class="section return"><dt>Returns</dt><dd>ID of the 'default' graphics mode. </dd></dl>

</div>
</div>
<a id="ga7d9aacb79763a8b06d415d83e549b6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d9aacb79763a8b06d415d83e549b6f1">&#9670;&nbsp;</a></span>setGraphicsMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::setGraphicsMode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="../../dc/d51/group__common__system__graphics.html#ggae815218bc6505c71d60e2f3fb5674b60a6b33e2bfa5cf0d7f0e190a523db0db95">kGfxModeNoFlags</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switch to the specified graphics mode.</p>
<p>If switching to the new mode fails, this method returns false.</p>
<p>The flag 'kGfxModeRender3d' is optional. It allows to switch to 3D-only rendering mode. In this mode, the game engine is allowed to use OpenGL(ES) directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>ID of the new graphics mode. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags for the new graphics mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the switch was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="gade71cd6f36f9c795ffc738f1dd5f1ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade71cd6f36f9c795ffc738f1dd5f1ff1">&#9670;&nbsp;</a></span>setGraphicsMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSystem::setGraphicsMode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch to the graphics mode with the given name.</p>
<p>If <code>name</code> is unknown, or if switching to the new mode fails, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new graphics mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the switch was successful, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is implemented using the setGraphicsMode(int) method, as well as <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga0dc1fa028b649304870d3b1c3085602c">getSupportedGraphicsModes()</a> and <a class="el" href="../../dc/d51/group__common__system__graphics.html#gafa94ee82b01397e91fd6c30fe35069df">getDefaultGraphicsMode()</a>. In particular, backends do not have to overload this! </dd></dl>

</div>
</div>
<a id="ga1ac9f23d6481dcab24dc0ced883d8674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ac9f23d6481dcab24dc0ced883d8674">&#9670;&nbsp;</a></span>getGraphicsMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getGraphicsMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine which graphics mode is currently active.</p>
<dl class="section return"><dt>Returns</dt><dd>ID of the active graphics mode. </dd></dl>

</div>
</div>
<a id="ga80a1e6c09495e5d71d6b911f30a47d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a1e6c09495e5d71d6b911f30a47d0d">&#9670;&nbsp;</a></span>resetGraphicsScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::resetGraphicsScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the graphics scale factor to x1.</p>
<p>Games with large screen sizes reset the scale to x1 so that the screen is not too big when starting the game. </p>

</div>
</div>
<a id="gab8f80c389e7d5aa14c3b76a29842b7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8f80c389e7d5aa14c3b76a29842b7fc">&#9670;&nbsp;</a></span>getSupportedAntiAliasingLevels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Common::Array&lt;uint&gt; OSystem::getSupportedAntiAliasingLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a list of supported levels of anti-aliasing.</p>
<p>Anti-aliasing only works when using one of the hardware-accelerated renderers. An empty list means anti-aliasing is not supported. </p>

</div>
</div>
<a id="ga84ed216d0fa410c8a97f4c96adb87721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84ed216d0fa410c8a97f4c96adb87721">&#9670;&nbsp;</a></span>getSupportedShaders()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="../../dd/dc1/struct_o_system_1_1_graphics_mode.html">GraphicsMode</a>* OSystem::getSupportedShaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a list of all hardware shaders supported by this backend.</p>
<p>This can be only hardware shaders. It is completely up to the backend maintainer to decide what is appropriate here and what not. The list is terminated by an all-zero entry.</p>
<dl class="section return"><dt>Returns</dt><dd>List of supported shaders. </dd></dl>

</div>
</div>
<a id="gadf9b2ad0d7a10c74bdc57e0732471b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf9b2ad0d7a10c74bdc57e0732471b3a">&#9670;&nbsp;</a></span>getDefaultShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getDefaultShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ID of the 'default' shader mode.</p>
<p>What exactly this means is up to the backend. This mode is set by the client code when no user overrides are present (i.e. if no custom shader mode is selected using the command line or a config file).</p>
<dl class="section return"><dt>Returns</dt><dd>ID of the 'default' shader mode. </dd></dl>

</div>
</div>
<a id="ga3f4a7110c7ac5e91efb8f9ccf918e6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f4a7110c7ac5e91efb8f9ccf918e6c9">&#9670;&nbsp;</a></span>setShader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::setShader </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switch to the specified shader mode.</p>
<p>If switching to the new mode fails, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the new shader mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the switch was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga64e59b53635de89a69d8f28a91265039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64e59b53635de89a69d8f28a91265039">&#9670;&nbsp;</a></span>setShader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSystem::setShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch to the shader mode with the given name.</p>
<p>If <code>name</code> is unknown, or if switching to the new mode fails, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new shader mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the switch was successful, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is implemented using the <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga3f4a7110c7ac5e91efb8f9ccf918e6c9">setShader(int)</a> method, as well as <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga84ed216d0fa410c8a97f4c96adb87721">getSupportedShaders()</a> and <a class="el" href="../../dc/d51/group__common__system__graphics.html#gadf9b2ad0d7a10c74bdc57e0732471b3a">getDefaultShader()</a>. In particular, backends do not have to overload this! </dd></dl>

</div>
</div>
<a id="gabb60de0651a38b168cf10d7be7f0f12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb60de0651a38b168cf10d7be7f0f12a">&#9670;&nbsp;</a></span>getShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine which shader is currently active.</p>
<dl class="section return"><dt>Returns</dt><dd>ID of the active shader. </dd></dl>

</div>
</div>
<a id="ga26ff83a077aea8010365cadd71e069ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ff83a077aea8010365cadd71e069ff">&#9670;&nbsp;</a></span>getSupportedStretchModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="../../dd/dc1/struct_o_system_1_1_graphics_mode.html">GraphicsMode</a>* OSystem::getSupportedStretchModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a list of all stretch modes supported by this backend.</p>
<p>It is completely up to the backend maintainer to decide what is appropriate here and what not. The list is terminated by an all-zero entry.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of supported stretch modes </dd></dl>

</div>
</div>
<a id="ga30fb4d311447dbb3275fd749c8a4a872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30fb4d311447dbb3275fd749c8a4a872">&#9670;&nbsp;</a></span>getDefaultStretchMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getDefaultStretchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ID of the 'default' stretch mode.</p>
<p>What exactly this means is up to the backend. This mode is set by the client code when no user overrides are present (i.e. if no custom stretch mode is selected using the command line or a config file).</p>
<dl class="section return"><dt>Returns</dt><dd>ID of the 'default' graphics mode. </dd></dl>

</div>
</div>
<a id="gaf5b29d7de9ef8eca12f102c75b71aeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5b29d7de9ef8eca12f102c75b71aeb5">&#9670;&nbsp;</a></span>setStretchMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::setStretchMode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switch to the specified stretch mode.</p>
<p>If switching to the new mode fails, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>ID of the new graphics mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the switch was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="gafc340ea066fa6e90c29389ba30d63ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc340ea066fa6e90c29389ba30d63ac1">&#9670;&nbsp;</a></span>setStretchMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSystem::setStretchMode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch to the stretch mode with the given name.</p>
<p>If <code>name</code> is unknown, or if switching to the new mode fails, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new stretch mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the switch was successful, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is implemented using the <a class="el" href="../../dc/d51/group__common__system__graphics.html#gaf5b29d7de9ef8eca12f102c75b71aeb5">setStretchMode(int)</a> method, as well as <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga26ff83a077aea8010365cadd71e069ff">getSupportedStretchModes()</a> and <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga30fb4d311447dbb3275fd749c8a4a872">getDefaultStretchMode()</a>. In particular, backends do not have to overload this! </dd></dl>

</div>
</div>
<a id="gac2947969d0e6bd53e2861504085f7dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2947969d0e6bd53e2861504085f7dd8">&#9670;&nbsp;</a></span>getStretchMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getStretchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine which stretch mode is currently active.</p>
<dl class="section return"><dt>Returns</dt><dd>ID of the active stretch mode. </dd></dl>

</div>
</div>
<a id="ga8574a1d7b9925c6573c65e45b46c1ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8574a1d7b9925c6573c65e45b46c1ada">&#9670;&nbsp;</a></span>initSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::initSize </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graphics::PixelFormat *&#160;</td>
          <td class="paramname"><em>format</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the size and color format of the virtual screen.</p>
<p>Typical sizes include:</p><ul>
<li>320x200 (e.g. for most SCUMM games, and Simon)</li>
<li>320x240 (e.g. for FM-TOWN SCUMM games)</li>
<li>640x480 (e.g. for Curse of Monkey Island)</li>
</ul>
<p>This is the resolution for which the client code generates data. This is not necessarily equal to the actual display size. For example, a backend may magnify the graphics to fit on the screen (see also the <a class="el" href="../../dd/dc1/struct_o_system_1_1_graphics_mode.html">GraphicsMode</a>), stretch the data to perform aspect ratio correction, or shrink it to fit on small screens (in cell phones).</p>
<p>Typical formats include:</p><ul>
<li>CLUT8 (e.g. 256 color, for most games)</li>
<li>RGB555 (e.g. 16-bit color, for later SCUMM HE games)</li>
<li>RGB565 (e.g. 16-bit color, for Urban Runner)</li>
</ul>
<p>This is the pixel format for which the client code generates data. It is not necessarily equal to the hardware pixel format. For example, a backend may perform color lookup of 8-bit graphics before pushing a screen to hardware, or correct the ARGB color order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>New virtual screen width. </td></tr>
    <tr><td class="paramname">height</td><td>New virtual screen height. </td></tr>
    <tr><td class="paramname">format</td><td>New virtual screen pixel format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d50cd90f90dc0d24cdfdfbc9af7409b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d50cd90f90dc0d24cdfdfbc9af7409b">&#9670;&nbsp;</a></span>initSizeHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::initSizeHint </td>
          <td>(</td>
          <td class="paramtype">const Graphics::ModeList &amp;&#160;</td>
          <td class="paramname"><em>modes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a list of graphics modes to the backend so it can make a decision about the best way to set up the display hardware.</p>
<p>Engines that switch between different virtual screen sizes during a game should call this function prior to any call to initSize. Engines that use only a single screen size do not need to call this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modes</td><td>List of graphics modes the engine will probably use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b0fa3319a08ccde3a7e59efede348b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b0fa3319a08ccde3a7e59efede348b0">&#9670;&nbsp;</a></span>getScreenChangeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getScreenChangeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an int value that is changed whenever any screen parameters (like the resolution) change, i.e. whenever EVENT_SCREEN_CHANGED is sent.</p>
<p>You can track this value in your code to detect screen changes in case you do not have full control over the event loop(s) being used (like the GUI code).</p>
<dl class="section return"><dt>Returns</dt><dd>Integer that can be used to track screen changes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Backends that generate EVENT_SCREEN_CHANGED events must overload this method appropriately. </dd></dl>

</div>
</div>
<a id="ga5e53c3c0d13ad5cd7b20f3ab42e71651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e53c3c0d13ad5cd7b20f3ab42e71651">&#9670;&nbsp;</a></span>beginGFXTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::beginGFXTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin a new GFX transaction, which is a sequence of GFX mode changes.</p>
<p>The idea behind GFX transactions is to make it possible to activate several different GFX changes at once as a "batch" operation. For example, assume we are running in 320x200 with a 2x scaler (thus using 640x400 pixels in total). Now, we want to switch to 640x400 with the 1x scaler. Without transactions, we have to choose whether we want to first switch the scaler mode, or first to 640x400 mode. In either case, depending on the backend implementation, problems may occur. For example, the window might briefly switch to 320x200 or 1280x800. Using transactions, this can be avoided.</p>
<dl class="section note"><dt>Note</dt><dd>Transaction support is optional, and the default implementations of the relevant methods simply do nothing.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga01ac3bef878805f47afea75769010e52">endGFXTransaction</a> </dd></dl>

</div>
</div>
<a id="ga01ac3bef878805f47afea75769010e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ac3bef878805f47afea75769010e52">&#9670;&nbsp;</a></span>endGFXTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga48fc8170ee88c60da61b98df8ceb159c">TransactionError</a> OSystem::endGFXTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End (and thereby commit) the current GFX transaction.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga5e53c3c0d13ad5cd7b20f3ab42e71651">beginGFXTransaction</a> </dd>
<dd>
kTransactionError</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>ORed combination of TransactionError values or 0 on success. </dd></dl>

</div>
</div>
<a id="ga1e2be76e9ae3a95e4ece3732588e0ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e2be76e9ae3a95e4ece3732588e0ac3">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16 OSystem::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the currently set virtual screen height.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga8574a1d7b9925c6573c65e45b46c1ada">initSize</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Currently set virtual screen height. </dd></dl>

</div>
</div>
<a id="ga09ffdad22d90db55c78774c75cbac711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09ffdad22d90db55c78774c75cbac711">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16 OSystem::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the currently set virtual screen width.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga8574a1d7b9925c6573c65e45b46c1ada">initSize</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Currently set virtual screen width. </dd></dl>

</div>
</div>
<a id="ga5a5b166e5de40e49ce075fa3f2509eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a5b166e5de40e49ce075fa3f2509eaa">&#9670;&nbsp;</a></span>getPaletteManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PaletteManager* OSystem::getPaletteManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the palette manager singleton.</p>
<p>For more information, see PaletteManager. </p>

</div>
</div>
<a id="gaafd1ca71d829f306b4b6d4cdaedcbcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafd1ca71d829f306b4b6d4cdaedcbcf7">&#9670;&nbsp;</a></span>copyRectToScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::copyRectToScreen </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blit a bitmap to the virtual screen.</p>
<p>The real screen will not immediately be updated to reflect the changes. Client code must call updateScreen to ensure any changes are visible to the user. This can be used to optimize drawing and reduce flicker.</p>
<p>If the current pixel format has one byte per pixel, the graphics data uses 8 bits per pixel, using the palette specified via setPalette. If more than one byte per pixel is in use, the graphics data uses the pixel format returned by getScreenFormat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer containing the graphics data source. </td></tr>
    <tr><td class="paramname">pitch</td><td>Pitch of the buffer (number of bytes in a scanline). </td></tr>
    <tr><td class="paramname">x</td><td>x coordinate of the destination rectangle. </td></tr>
    <tr><td class="paramname">y</td><td>y coordinate of the destination rectangle. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the destination rectangle. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the destination rectangle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The specified destination rectangle must be completly contained in the visible screen space, and must be non-empty. If not, a backend may or may not perform clipping, trigger an assert, or silently corrupt memory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga6983105f21ef8bdf828a51e4cec4cfe8">updateScreen</a> </dd>
<dd>
getScreenFormat </dd></dl>

</div>
</div>
<a id="ga56a4f05596bd55c887e35a34937939c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a4f05596bd55c887e35a34937939c5">&#9670;&nbsp;</a></span>lockScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Graphics::Surface* OSystem::lockScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lock the active screen framebuffer and return a Graphics::Surface representing it.</p>
<p>The caller can then perform arbitrary graphics transformations on the framebuffer (blitting, scrolling, etc.). Must be followed by a matching call to <a class="el" href="../../dc/d51/group__common__system__graphics.html#gab87138a721368bed7abde76c0f24c880">unlockScreen()</a>. Code that is calling this should make sure to only lock the framebuffer for the shortest time possible, as the whole system is potentially stalled while the lock is active.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if an error occurs. Otherwise, a surface with the pixel format described by getScreenFormat is returned.</dd></dl>
<p>The returned surface must <em>not</em> be deleted by the client code.</p>
<dl class="section see"><dt>See also</dt><dd>getScreenFormat </dd></dl>

</div>
</div>
<a id="gab87138a721368bed7abde76c0f24c880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab87138a721368bed7abde76c0f24c880">&#9670;&nbsp;</a></span>unlockScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::unlockScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlock the screen framebuffer, and mark it as dirty, i.e. during the next <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga6983105f21ef8bdf828a51e4cec4cfe8">updateScreen()</a> call, the whole screen will be updated. </p>

</div>
</div>
<a id="gaf12df877f26c4db662aece81be9bf833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf12df877f26c4db662aece81be9bf833">&#9670;&nbsp;</a></span>fillScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::fillScreen </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the screen with the given color value. </p>

</div>
</div>
<a id="ga6983105f21ef8bdf828a51e4cec4cfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6983105f21ef8bdf828a51e4cec4cfe8">&#9670;&nbsp;</a></span>updateScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::updateScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush the whole screen, i.e. render the current content of the screen framebuffer to the display.</p>
<p>This method may be called very often by engines. Backends are hence supposed to only perform any redrawing if it is necessary and otherwise return immediately. See <a href="https://wiki.scummvm.org/index.php/HOWTO-Backends#updateScreen.28.29_method">https://wiki.scummvm.org/index.php/HOWTO-Backends#updateScreen.28.29_method</a> </p>

</div>
</div>
<a id="ga2f9a92117c13ae543fcaa6769a31614d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f9a92117c13ae543fcaa6769a31614d">&#9670;&nbsp;</a></span>setShakePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::setShakePos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shakeXOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shakeYOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set current shake position, a feature needed for some SCUMM screen effects.</p>
<p>The effect causes the displayed graphics to be shifted upwards by the specified (always positive) offset. The area at the bottom of the screen which is moved into view by this is filled with black. This does not cause any graphic data to be lost. To restore the original view, the game engine only has to call this method again with offset equal to zero. No calls to copyRectToScreen are necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shakeXOffset</td><td>Shake x offset. </td></tr>
    <tr><td class="paramname">shakeYOffset</td><td>Shake y offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is currently used in the SCUMM, QUEEN, KYRA, SCI, DREAMWEB, SUPERNOVA, TEENAGENT, TOLTECS, ULTIMA, and PETKA engines. </dd></dl>

</div>
</div>
<a id="ga337901711715fd99610be213a9e0dab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga337901711715fd99610be213a9e0dab0">&#9670;&nbsp;</a></span>setFocusRectangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::setFocusRectangle </td>
          <td>(</td>
          <td class="paramtype">const Common::Rect &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the area of the screen that has the focus.</p>
<p>For example, when a character is speaking, they will have the focus. This allows for pan-and-scan style views where the backend can follow the speaking character or area of interest on the screen.</p>
<p>The backend is responsible for clipping the rectangle and deciding how best to zoom the screen to show any shape and size rectangle the engine provides.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>Rectangle on the screen to be focused on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga6676d67905f65114a3e95f6b45227b67">clearFocusRectangle</a> </dd></dl>

</div>
</div>
<a id="ga6676d67905f65114a3e95f6b45227b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6676d67905f65114a3e95f6b45227b67">&#9670;&nbsp;</a></span>clearFocusRectangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::clearFocusRectangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the focus set by a call to <a class="el" href="../../dc/d51/group__common__system__graphics.html#ga337901711715fd99610be213a9e0dab0">setFocusRectangle()</a>.</p>
<p>This allows the engine to clear the focus when no particular area of the screen has the focus.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d51/group__common__system__graphics.html#ga337901711715fd99610be213a9e0dab0">setFocusRectangle</a> </dd></dl>

</div>
</div>
<a id="gac31a87a460c151f736111749fba629f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac31a87a460c151f736111749fba629f2">&#9670;&nbsp;</a></span>saveScreenshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::saveScreenshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instruct the backend to capture a screenshot of the current screen.</p>
<p>The backend can persist it the way it considers appropriate. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
