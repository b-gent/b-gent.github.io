<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="cache-control" content="max-age=86400"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ScummVM API documentation: OSystem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="scummvm_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ScummVM API documentation
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_o_system.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_o_system-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OSystem Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__common.html">Common API</a> &raquo; <a class="el" href="group__common__system.html">System</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="system_8h_source.html">system.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OSystem:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_system.png" usemap="#OSystem_map" alt=""/>
  <map id="OSystem_map" name="OSystem_map">
<area href="class_common_1_1_non_copyable.html" alt="Common::NonCopyable" shape="rect" coords="0,0,143,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_o_system_1_1_graphics_mode.html">GraphicsMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a365ed21b6c63b30335a3dae4086325c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a365ed21b6c63b30335a3dae4086325c8">destroy</a> ()</td></tr>
<tr class="separator:a365ed21b6c63b30335a3dae4086325c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed174516272a646d22ababf78093134"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a6ed174516272a646d22ababf78093134">init</a> ()</td></tr>
<tr class="separator:a6ed174516272a646d22ababf78093134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e51e2c96b42377b7f18a2b603b8bd96"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a3e51e2c96b42377b7f18a2b603b8bd96">initBackend</a> ()</td></tr>
<tr class="separator:a3e51e2c96b42377b7f18a2b603b8bd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a339d637d45a8c6723840d4a725acb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a9a339d637d45a8c6723840d4a725acb7">backendInitialized</a> () const</td></tr>
<tr class="separator:a9a339d637d45a8c6723840d4a725acb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df641f992e264799bca4e668b55a874"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a5df641f992e264799bca4e668b55a874">engineInit</a> ()</td></tr>
<tr class="separator:a5df641f992e264799bca4e668b55a874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf21ec8b60e1389428b3b5cc2a4bcbe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a5bf21ec8b60e1389428b3b5cc2a4bcbe">engineDone</a> ()</td></tr>
<tr class="separator:a5bf21ec8b60e1389428b3b5cc2a4bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Overlay</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>In order to be able to display dialogs atop the game graphics, backends must provide an overlay mode.</p>
<p>The overlay is currently forced at 16 bpp.</p>
<p>For 'coolness' we usually want to have an overlay which is blended over the game graphics. On backends which support alpha blending, this is no issue; but on other systems this needs some trickery.</p>
<p>Essentially, we fake (alpha) blending on these systems by copying the current game graphics into the overlay buffer when activating the overlay, then manually compose whatever graphics we want to show in the overlay. This works because we assume the game to be "paused" whenever an overlay is active. </p>
</div></td></tr>
<tr class="memitem:a7e87827f0a7cd665c569d6642a9da9e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a7e87827f0a7cd665c569d6642a9da9e1">showOverlay</a> ()=0</td></tr>
<tr class="separator:a7e87827f0a7cd665c569d6642a9da9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e381ce4d94579030a9d834dc514498c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a1e381ce4d94579030a9d834dc514498c">hideOverlay</a> ()=0</td></tr>
<tr class="separator:a1e381ce4d94579030a9d834dc514498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e96d22ca114352872ac28a7105c465"><td class="memItemLeft" align="right" valign="top">virtual Graphics::PixelFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a61e96d22ca114352872ac28a7105c465">getOverlayFormat</a> () const =0</td></tr>
<tr class="separator:a61e96d22ca114352872ac28a7105c465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8962537874e1b9b26db0d2848c68b802"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a8962537874e1b9b26db0d2848c68b802">clearOverlay</a> ()=0</td></tr>
<tr class="separator:a8962537874e1b9b26db0d2848c68b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5f027431cd407947e375b7c10cb21c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aee5f027431cd407947e375b7c10cb21c">grabOverlay</a> (void *buf, int pitch)=0</td></tr>
<tr class="separator:aee5f027431cd407947e375b7c10cb21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb8dd7938c7ad39a84ada94c5f5b53a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a5fb8dd7938c7ad39a84ada94c5f5b53a">copyRectToOverlay</a> (const void *buf, int pitch, int x, int y, int w, int h)=0</td></tr>
<tr class="separator:a5fb8dd7938c7ad39a84ada94c5f5b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ff48460f11538647ffc7d807e41923"><td class="memItemLeft" align="right" valign="top">virtual int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a28ff48460f11538647ffc7d807e41923">getOverlayHeight</a> ()=0</td></tr>
<tr class="separator:a28ff48460f11538647ffc7d807e41923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6095edde38573f40e381dd470acf4d6"><td class="memItemLeft" align="right" valign="top">virtual int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ab6095edde38573f40e381dd470acf4d6">getOverlayWidth</a> ()=0</td></tr>
<tr class="separator:ab6095edde38573f40e381dd470acf4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mouse</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>This is the lower level implementation as provided by the backends. The engines should use the Graphics::CursorManager class instead of using it directly. </p>
</div></td></tr>
<tr class="memitem:adba65b23c102e1a3ecf177ffdde0ddc1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#adba65b23c102e1a3ecf177ffdde0ddc1">showMouse</a> (bool visible)=0</td></tr>
<tr class="separator:adba65b23c102e1a3ecf177ffdde0ddc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecab84670def917107d6c1b5ca3b82c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aecab84670def917107d6c1b5ca3b82c3">warpMouse</a> (int x, int y)=0</td></tr>
<tr class="separator:aecab84670def917107d6c1b5ca3b82c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1bbc0923c0cc7bfe2660a63a224edd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a2e1bbc0923c0cc7bfe2660a63a224edd">setMouseCursor</a> (const void *buf, uint w, uint h, int hotspotX, int hotspotY, uint32 keycolor, bool dontScale=false, const Graphics::PixelFormat *format=nullptr)=0</td></tr>
<tr class="separator:a2e1bbc0923c0cc7bfe2660a63a224edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba50e0cd9ba60787a50ac4d64d49a0b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aba50e0cd9ba60787a50ac4d64d49a0b6">setCursorPalette</a> (const byte *colors, uint start, uint num)</td></tr>
<tr class="separator:aba50e0cd9ba60787a50ac4d64d49a0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Events and Time</div></td></tr>
<tr class="memitem:a323083759ebb539578dcc9488bbf2995"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a323083759ebb539578dcc9488bbf2995">getMillis</a> (bool skipRecord=false)=0</td></tr>
<tr class="separator:a323083759ebb539578dcc9488bbf2995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e05463c6a2803303a9dca2eb3beed1e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a4e05463c6a2803303a9dca2eb3beed1e">delayMillis</a> (uint msecs)=0</td></tr>
<tr class="separator:a4e05463c6a2803303a9dca2eb3beed1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6973ec117b3fd87e22e20bd506094470"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a6973ec117b3fd87e22e20bd506094470">getTimeAndDate</a> (<a class="el" href="struct_time_date.html">TimeDate</a> &amp;t) const =0</td></tr>
<tr class="separator:a6973ec117b3fd87e22e20bd506094470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb38c76beedc540c25e038e32e630bec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_timer_manager.html">Common::TimerManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#abb38c76beedc540c25e038e32e630bec">getTimerManager</a> ()</td></tr>
<tr class="separator:abb38c76beedc540c25e038e32e630bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6565e99280a20785dd0d214b16aa59b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_event_manager.html">Common::EventManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#af6565e99280a20785dd0d214b16aa59b">getEventManager</a> ()</td></tr>
<tr class="separator:af6565e99280a20785dd0d214b16aa59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d616cd3e021300d2ff1f6f175d425a5"><td class="memItemLeft" align="right" valign="top">virtual Common::HardwareInputSet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a0d616cd3e021300d2ff1f6f175d425a5">getHardwareInputSet</a> ()</td></tr>
<tr class="separator:a0d616cd3e021300d2ff1f6f175d425a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59947e12fb735f772b11272e5e8fb49"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_array.html">Common::KeymapArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#af59947e12fb735f772b11272e5e8fb49">getGlobalKeymaps</a> ()</td></tr>
<tr class="separator:af59947e12fb735f772b11272e5e8fb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88d7fd17b7f1e6947e16eb5f9e97353"><td class="memItemLeft" align="right" valign="top">virtual Common::KeymapperDefaultBindings *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ab88d7fd17b7f1e6947e16eb5f9e97353">getKeymapperDefaultBindings</a> ()</td></tr>
<tr class="separator:ab88d7fd17b7f1e6947e16eb5f9e97353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sound</div></td></tr>
<tr class="memitem:a4d4e32ada84b5cac226991cac3ac4541"><td class="memItemLeft" align="right" valign="top">virtual Audio::Mixer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a4d4e32ada84b5cac226991cac3ac4541">getMixer</a> ()=0</td></tr>
<tr class="separator:a4d4e32ada84b5cac226991cac3ac4541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio CD</div></td></tr>
<tr class="memitem:a36d8e52c3aab3c60dd37ecb57f859c6f"><td class="memItemLeft" align="right" valign="top">AudioCDManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a36d8e52c3aab3c60dd37ecb57f859c6f">getAudioCDManager</a> ()</td></tr>
<tr class="separator:a36d8e52c3aab3c60dd37ecb57f859c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous</div></td></tr>
<tr class="memitem:af2b69fefdd3500f504bd6923ea0905b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#af2b69fefdd3500f504bd6923ea0905b5">quit</a> ()=0</td></tr>
<tr class="separator:af2b69fefdd3500f504bd6923ea0905b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01edf361e28bb969fb8673e218c3cd59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a01edf361e28bb969fb8673e218c3cd59">fatalError</a> ()</td></tr>
<tr class="separator:a01edf361e28bb969fb8673e218c3cd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb6b4d0dc2ad83b564357e9cf001fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#acaeb6b4d0dc2ad83b564357e9cf001fb">setWindowCaption</a> (const char *caption)</td></tr>
<tr class="separator:acaeb6b4d0dc2ad83b564357e9cf001fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d4c02a92b9bc4b9e8f8bc5ee3d0234"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aa6d4c02a92b9bc4b9e8f8bc5ee3d0234">displayMessageOnOSD</a> (const <a class="el" href="class_common_1_1_u32_string.html">Common::U32String</a> &amp;msg)=0</td></tr>
<tr class="separator:aa6d4c02a92b9bc4b9e8f8bc5ee3d0234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e25f196f210f0ff0503e41610d52d00"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a0e25f196f210f0ff0503e41610d52d00">displayActivityIconOnOSD</a> (const Graphics::Surface *icon)=0</td></tr>
<tr class="separator:a0e25f196f210f0ff0503e41610d52d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d8463193d5e21efcefdd869c408f66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_save_file_manager.html">Common::SaveFileManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ab8d8463193d5e21efcefdd869c408f66">getSavefileManager</a> ()</td></tr>
<tr class="separator:ab8d8463193d5e21efcefdd869c408f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d25f4c9f5aa7f786eaf1be0bb01256c"><td class="memItemLeft" align="right" valign="top">virtual FilesystemFactory *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a6d25f4c9f5aa7f786eaf1be0bb01256c">getFilesystemFactory</a> ()</td></tr>
<tr class="separator:a6d25f4c9f5aa7f786eaf1be0bb01256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3499c8f9d327006a82fc8685a49f2996"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a3499c8f9d327006a82fc8685a49f2996">addSysArchivesToSearchSet</a> (<a class="el" href="class_common_1_1_search_set.html">Common::SearchSet</a> &amp;s, int priority=0)</td></tr>
<tr class="separator:a3499c8f9d327006a82fc8685a49f2996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd885a1f7449639fa8dad730b147d7e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_seekable_read_stream.html">Common::SeekableReadStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#afd885a1f7449639fa8dad730b147d7e7">createConfigReadStream</a> ()</td></tr>
<tr class="separator:afd885a1f7449639fa8dad730b147d7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03400a28f21de0ec695367f8e9161e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_write_stream.html">Common::WriteStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ab03400a28f21de0ec695367f8e9161e7">createConfigWriteStream</a> ()</td></tr>
<tr class="separator:ab03400a28f21de0ec695367f8e9161e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d7188a18abfc05cf31e5eb3d03c521"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_string.html">Common::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a68d7188a18abfc05cf31e5eb3d03c521">getDefaultConfigFileName</a> ()</td></tr>
<tr class="separator:a68d7188a18abfc05cf31e5eb3d03c521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae6ac8f980d2c2640d8a3cbe22a5ae4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a8ae6ac8f980d2c2640d8a3cbe22a5ae4">logMessage</a> (LogMessageType::Type type, const char *message)=0</td></tr>
<tr class="separator:a8ae6ac8f980d2c2640d8a3cbe22a5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04e49df91bbab6c4ad34e3c2ba52b33"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ae04e49df91bbab6c4ad34e3c2ba52b33">displayLogFile</a> ()</td></tr>
<tr class="separator:ae04e49df91bbab6c4ad34e3c2ba52b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4708db58c3e0b2d363b1b417752951"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#abb4708db58c3e0b2d363b1b417752951">hasTextInClipboard</a> ()</td></tr>
<tr class="separator:abb4708db58c3e0b2d363b1b417752951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5872a0daeae7b00a721cf894e8cf280a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_u32_string.html">Common::U32String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a5872a0daeae7b00a721cf894e8cf280a">getTextFromClipboard</a> ()</td></tr>
<tr class="separator:a5872a0daeae7b00a721cf894e8cf280a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8012946b2e61b9f92100f686f035391"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ac8012946b2e61b9f92100f686f035391">setTextInClipboard</a> (const <a class="el" href="class_common_1_1_u32_string.html">Common::U32String</a> &amp;text)</td></tr>
<tr class="separator:ac8012946b2e61b9f92100f686f035391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f77b6796f4990c1b3791f800ba789b7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a5f77b6796f4990c1b3791f800ba789b7">openUrl</a> (const <a class="el" href="class_common_1_1_string.html">Common::String</a> &amp;url)</td></tr>
<tr class="separator:a5f77b6796f4990c1b3791f800ba789b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f63139426222890268fb5fe71c1b47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_string.html">Common::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a44f63139426222890268fb5fe71c1b47">getSystemLanguage</a> () const</td></tr>
<tr class="separator:a44f63139426222890268fb5fe71c1b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8958d2ea676f43809ed767543ed3d84c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a8958d2ea676f43809ed767543ed3d84c">isConnectionLimited</a> ()</td></tr>
<tr class="separator:a8958d2ea676f43809ed767543ed3d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac97358efae164cff487cb67298d12a9c"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ac97358efae164cff487cb67298d12a9c">convertEncoding</a> (const char *to, const char *from, const char *string, size_t length)</td></tr>
<tr class="separator:ac97358efae164cff487cb67298d12a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9b6b474f9c7c01b07880dcdd8600ecdb"><td class="memItemLeft" align="right" valign="top"><a id="a9b6b474f9c7c01b07880dcdd8600ecdb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Common::Encoding</b></td></tr>
<tr class="separator:a9b6b474f9c7c01b07880dcdd8600ecdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Module slots</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb950ef4c16a1024264b0255e2598c950"></a>For backend authors only, the following pointers (= "slots) to various subsystem managers / factories / etc. can and should be set to a suitable instance of the respective type.</p>
<p>For some of the slots, a default instance is set if your backend does not do so. For details, please look at the documentation of each slot.</p>
<p>A backend may setup slot values in its <a class="el" href="class_o_system.html#a3e51e2c96b42377b7f18a2b603b8bd96">initBackend()</a> method, its constructor or somewhere in between. But it must a slot's value no later than in its <a class="el" href="class_o_system.html#a3e51e2c96b42377b7f18a2b603b8bd96">initBackend()</a> implementation, because <a class="el" href="class_o_system.html#a3e51e2c96b42377b7f18a2b603b8bd96">OSystem::initBackend()</a> will create any default instances if none has been set yet (and for other slots, will verify that one has been set; if not, an error may be generated). </p>
</td></tr>
<tr class="memitem:a49364817fe70fbb97a06667c1f467afc"><td class="memItemLeft" align="right" valign="top">AudioCDManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a49364817fe70fbb97a06667c1f467afc">_audiocdManager</a></td></tr>
<tr class="separator:a49364817fe70fbb97a06667c1f467afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c080fafdc4f99c3d1a465b5266fbec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_event_manager.html">Common::EventManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ad4c080fafdc4f99c3d1a465b5266fbec">_eventManager</a></td></tr>
<tr class="separator:ad4c080fafdc4f99c3d1a465b5266fbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7f5d775e24a17dcdffa896e9131bc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_timer_manager.html">Common::TimerManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aeb7f5d775e24a17dcdffa896e9131bc5">_timerManager</a></td></tr>
<tr class="separator:aeb7f5d775e24a17dcdffa896e9131bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88bb97da5abfc76d877eb60df948367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_save_file_manager.html">Common::SaveFileManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ae88bb97da5abfc76d877eb60df948367">_savefileManager</a></td></tr>
<tr class="separator:ae88bb97da5abfc76d877eb60df948367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad8b776858aa183be882f5f36b2d42e"><td class="memItemLeft" align="right" valign="top">FilesystemFactory *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a1ad8b776858aa183be882f5f36b2d42e">_fsFactory</a></td></tr>
<tr class="separator:a1ad8b776858aa183be882f5f36b2d42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370071a2580d26ef36202a05bdeddff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_u32_string.html">Common::U32String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a370071a2580d26ef36202a05bdeddff2">_clipboard</a></td></tr>
<tr class="separator:a370071a2580d26ef36202a05bdeddff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491c45a2ace9dc87bbb04b1debef050b"><td class="memItemLeft" align="right" valign="top"><a id="a491c45a2ace9dc87bbb04b1debef050b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_dummyUnused</b></td></tr>
<tr class="separator:a491c45a2ace9dc87bbb04b1debef050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Feature flags</h2></td></tr>
<tr class="memitem:ab3040fae0470d961dcb5a3f6b85e8d44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44">Feature</a> { <br />
&#160;&#160;<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a38268fda3a18b9af89c486b5fe0cb4c1">kFeatureFullscreenMode</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a79f99ab355ea18b253e5f1e7923935d8">kFeatureAspectRatioCorrection</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a2a2b7fa172f929709cbfa7fe5d67dc75">kFeatureFilteringMode</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a1e7054740414bfe948e24bafb907c6e9">kFeatureStretchMode</a>, 
<br />
&#160;&#160;<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a22dc4fd4d1fab3654ce27d91efbcd80a">kFeatureVirtualKeyboard</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44ace5216ddcd06da7fbd891de81d52a445">kFeatureCursorPalette</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44ac5e691958c1daed8f13fc4e507275f6d">kFeatureOverlaySupportsAlpha</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a09f5f6a88e5e05c355de6ca0be7a80a1">kFeatureIconifyWindow</a>, 
<br />
&#160;&#160;<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a16ef4993243f8e9f065aeeb86e8077ea">kFeatureDisplayLogFile</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a1e13ae52f03883db0b14bd3934c63f56">kFeatureClipboardSupport</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a83c50fc0aba00939f42af323ae2ba9ad">kFeatureOpenUrl</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a32d7ab5a779bcb3a7d4140a624299982">kFeatureOnScreenControl</a>, 
<br />
&#160;&#160;<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a871a467bcf76d80930f9393678f1723c">kFeatureTouchpadMode</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a83bfab7d13c24b36c2975b7b407c0c68">kFeatureSwapMenuAndBackButtons</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44aa00e1d25107b008db761b746807cec46">kFeatureKbdMouseSpeed</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a8917d1d89a9c235a1ae5eabb064da27a">kFeatureJoystickDeadzone</a>, 
<br />
&#160;&#160;<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44ac441833f0cf9b43ca47fe05b777128d8">kFeatureShader</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a6e86a84941b00145e3a6672cc01d9f0a">kFeatureSystemBrowserDialog</a>, 
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44a74478943d905f49c18fc06f77871a97c">kFeatureNoQuit</a>
<br />
 }</td></tr>
<tr class="separator:ab3040fae0470d961dcb5a3f6b85e8d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7700c81f7be95f41ad2b7b75a285cd9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ae7700c81f7be95f41ad2b7b75a285cd9">hasFeature</a> (<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44">Feature</a> f)</td></tr>
<tr class="separator:ae7700c81f7be95f41ad2b7b75a285cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa9ad64044d7775231a5bb47646dabe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aefa9ad64044d7775231a5bb47646dabe">setFeatureState</a> (<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44">Feature</a> f, bool enable)</td></tr>
<tr class="separator:aefa9ad64044d7775231a5bb47646dabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fe9288ca94a3d992d1212ef8cec311"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a03fe9288ca94a3d992d1212ef8cec311">getFeatureState</a> (<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44">Feature</a> f)</td></tr>
<tr class="separator:a03fe9288ca94a3d992d1212ef8cec311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Graphics</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd334dfcea59127bedfcdbe0a3ee7f494"></a>The way graphics work in the class <a class="el" href="class_o_system.html">OSystem</a> are meant to make it possible for game frontends to implement all they need in an efficient manner. The downside of this is that it may be rather complicated for backend authors to fully understand and implement the semantics of the <a class="el" href="class_o_system.html">OSystem</a> interface.</p>
<p>The graphics visible to the user in the end are actually composed in three layers: the game graphics, the overlay graphics, and the mouse.</p>
<p>First, there are the game graphics. The methods in this section deal with them exclusively. In particular, the size of the game graphics is defined by a call to <a class="el" href="class_o_system.html#a8574a1d7b9925c6573c65e45b46c1ada">initSize()</a>, and <a class="el" href="class_o_system.html#aafd1ca71d829f306b4b6d4cdaedcbcf7">copyRectToScreen()</a> blits the data in the current pixel format into the game layer. Let W and H denote the width and height of the game graphics.</p>
<p>Before the user sees these graphics, the backend may apply some transformations to it; for example, the may be scaled to better fit on the visible screen; or aspect ratio correction may be performed (see kFeatureAspectRatioCorrection). As a result of this, a pixel of the game graphics may occupy a region bigger than a single pixel on the screen. We define p_w and p_h to be the width resp. height of a game pixel on the screen.</p>
<p>In addition, there is a vertical "shake offset" (as defined by setShakePos) which is used in some games to provide a shaking effect. Note that shaking is applied to all three layers, i.e. also to the overlay and the mouse. We denote the shake offset by S.</p>
<p>Putting this together, a pixel (x,y) of the game graphics is transformed to a rectangle of height p_h and width p_w appearing at position (p_w * x, p_hw * (y + S)) on the real screen (in addition, a backend may choose to offset everything, e.g. to center the graphics on the screen).</p>
<p>The next layer is the overlay. It is composed over the game graphics. Historically the overlay size had always been a multiple of the game resolution, for example when the game resolution was 320x200 and the user selected a 2x scaler and did not enable aspect ratio correction it had a size of 640x400. An exception was the aspect ratio correction, which did allow for non multiples of the vertical resolution of the game screen. Nowadays the overlay size does not need to have any relation to the game resolution though, for example the overlay resolution might be the same as the physical screen resolution. The overlay is forced to a 16bpp mode right now.</p>
<p>Finally, there is the mouse layer. This layer doesn't have to actually exist within the backend &ndash; it all depends on how a backend chooses to implement mouse cursors, but in the default SDL backend, it really is a separate layer. The mouse can have a palette of its own, if the backend supports it.</p>
<p>On a note for <a class="el" href="class_o_system.html">OSystem</a> users here. We do not require our graphics to be thread safe and in fact most/all backends using OpenGL are not. So do <em>not</em> try to call any of these functions from a timer and/or audio callback (like readBuffer of AudioStreams). </p>
</td></tr>
<tr class="memitem:a48fc8170ee88c60da61b98df8ceb159c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159c">TransactionError</a> { <br />
&#160;&#160;<a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159ca66fa9aad355638a74399dc4c3bfb8ac4">kTransactionSuccess</a> = 0, 
<a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159ca63716f7d521a43fbe27c50832eb00dce">kTransactionAspectRatioFailed</a> = (1 &lt;&lt; 0), 
<a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159caa4b9c084a757f5b203ca709a0f614752">kTransactionFullscreenFailed</a> = (1 &lt;&lt; 1), 
<a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159ca28799b1e6ddcbb2f2d0cc34122bef264">kTransactionModeSwitchFailed</a> = (1 &lt;&lt; 2), 
<br />
&#160;&#160;<a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159cac8a04ee3b1bef026790377fe79e79839">kTransactionSizeChangeFailed</a> = (1 &lt;&lt; 3), 
<a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159ca7a40f191e89d29236bcea4c10efc003a">kTransactionFormatNotSupported</a> = (1 &lt;&lt; 4), 
<a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159ca6d79fe85fb37a1856e950cb2c4f155b1">kTransactionFilteringFailed</a> = (1 &lt;&lt; 5), 
<a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159ca00239d2e06d1e7f765ea82b38e61df95">kTransactionStretchModeSwitchFailed</a> = (1 &lt;&lt; 6)
<br />
 }</td></tr>
<tr class="separator:a48fc8170ee88c60da61b98df8ceb159c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc1fa028b649304870d3b1c3085602c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_o_system_1_1_graphics_mode.html">GraphicsMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a0dc1fa028b649304870d3b1c3085602c">getSupportedGraphicsModes</a> () const</td></tr>
<tr class="separator:a0dc1fa028b649304870d3b1c3085602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa94ee82b01397e91fd6c30fe35069df"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#afa94ee82b01397e91fd6c30fe35069df">getDefaultGraphicsMode</a> () const</td></tr>
<tr class="separator:afa94ee82b01397e91fd6c30fe35069df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff49759635422c63cc49b224668ba971"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aff49759635422c63cc49b224668ba971">setGraphicsMode</a> (int mode)</td></tr>
<tr class="separator:aff49759635422c63cc49b224668ba971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade71cd6f36f9c795ffc738f1dd5f1ff1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ade71cd6f36f9c795ffc738f1dd5f1ff1">setGraphicsMode</a> (const char *name)</td></tr>
<tr class="separator:ade71cd6f36f9c795ffc738f1dd5f1ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac9f23d6481dcab24dc0ced883d8674"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a1ac9f23d6481dcab24dc0ced883d8674">getGraphicsMode</a> () const</td></tr>
<tr class="separator:a1ac9f23d6481dcab24dc0ced883d8674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a1e6c09495e5d71d6b911f30a47d0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a80a1e6c09495e5d71d6b911f30a47d0d">resetGraphicsScale</a> ()</td></tr>
<tr class="separator:a80a1e6c09495e5d71d6b911f30a47d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f7c6fd2ef7072e92ce6d087479f3c8"><td class="memItemLeft" align="right" valign="top"><a id="a15f7c6fd2ef7072e92ce6d087479f3c8"></a>
Graphics::PixelFormat&#160;</td><td class="memItemRight" valign="bottom"><b>getScreenFormat</b> () const</td></tr>
<tr class="separator:a15f7c6fd2ef7072e92ce6d087479f3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214571d455baa7a6c84354bf1e21280f"><td class="memItemLeft" align="right" valign="top"><a id="a214571d455baa7a6c84354bf1e21280f"></a>
<a class="el" href="class_common_1_1_list.html">Common::List</a>&lt; Graphics::PixelFormat &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSupportedFormats</b> () const</td></tr>
<tr class="separator:a214571d455baa7a6c84354bf1e21280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed216d0fa410c8a97f4c96adb87721"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_o_system_1_1_graphics_mode.html">GraphicsMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a84ed216d0fa410c8a97f4c96adb87721">getSupportedShaders</a> () const</td></tr>
<tr class="separator:a84ed216d0fa410c8a97f4c96adb87721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9b2ad0d7a10c74bdc57e0732471b3a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#adf9b2ad0d7a10c74bdc57e0732471b3a">getDefaultShader</a> () const</td></tr>
<tr class="separator:adf9b2ad0d7a10c74bdc57e0732471b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4a7110c7ac5e91efb8f9ccf918e6c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a3f4a7110c7ac5e91efb8f9ccf918e6c9">setShader</a> (int id)</td></tr>
<tr class="separator:a3f4a7110c7ac5e91efb8f9ccf918e6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e59b53635de89a69d8f28a91265039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a64e59b53635de89a69d8f28a91265039">setShader</a> (const char *name)</td></tr>
<tr class="separator:a64e59b53635de89a69d8f28a91265039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb60de0651a38b168cf10d7be7f0f12a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#abb60de0651a38b168cf10d7be7f0f12a">getShader</a> () const</td></tr>
<tr class="separator:abb60de0651a38b168cf10d7be7f0f12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ff83a077aea8010365cadd71e069ff"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_o_system_1_1_graphics_mode.html">GraphicsMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a26ff83a077aea8010365cadd71e069ff">getSupportedStretchModes</a> () const</td></tr>
<tr class="separator:a26ff83a077aea8010365cadd71e069ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fb4d311447dbb3275fd749c8a4a872"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a30fb4d311447dbb3275fd749c8a4a872">getDefaultStretchMode</a> () const</td></tr>
<tr class="separator:a30fb4d311447dbb3275fd749c8a4a872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b29d7de9ef8eca12f102c75b71aeb5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#af5b29d7de9ef8eca12f102c75b71aeb5">setStretchMode</a> (int mode)</td></tr>
<tr class="separator:af5b29d7de9ef8eca12f102c75b71aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc340ea066fa6e90c29389ba30d63ac1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#afc340ea066fa6e90c29389ba30d63ac1">setStretchMode</a> (const char *name)</td></tr>
<tr class="separator:afc340ea066fa6e90c29389ba30d63ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2947969d0e6bd53e2861504085f7dd8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ac2947969d0e6bd53e2861504085f7dd8">getStretchMode</a> () const</td></tr>
<tr class="separator:ac2947969d0e6bd53e2861504085f7dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574a1d7b9925c6573c65e45b46c1ada"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a8574a1d7b9925c6573c65e45b46c1ada">initSize</a> (uint width, uint height, const Graphics::PixelFormat *format=nullptr)=0</td></tr>
<tr class="separator:a8574a1d7b9925c6573c65e45b46c1ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d50cd90f90dc0d24cdfdfbc9af7409b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a0d50cd90f90dc0d24cdfdfbc9af7409b">initSizeHint</a> (const Graphics::ModeList &amp;modes)</td></tr>
<tr class="separator:a0d50cd90f90dc0d24cdfdfbc9af7409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0fa3319a08ccde3a7e59efede348b0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a9b0fa3319a08ccde3a7e59efede348b0">getScreenChangeID</a> () const</td></tr>
<tr class="separator:a9b0fa3319a08ccde3a7e59efede348b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e53c3c0d13ad5cd7b20f3ab42e71651"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a5e53c3c0d13ad5cd7b20f3ab42e71651">beginGFXTransaction</a> ()</td></tr>
<tr class="separator:a5e53c3c0d13ad5cd7b20f3ab42e71651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ac3bef878805f47afea75769010e52"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159c">TransactionError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a01ac3bef878805f47afea75769010e52">endGFXTransaction</a> ()</td></tr>
<tr class="separator:a01ac3bef878805f47afea75769010e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2be76e9ae3a95e4ece3732588e0ac3"><td class="memItemLeft" align="right" valign="top">virtual int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a1e2be76e9ae3a95e4ece3732588e0ac3">getHeight</a> ()=0</td></tr>
<tr class="separator:a1e2be76e9ae3a95e4ece3732588e0ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ffdad22d90db55c78774c75cbac711"><td class="memItemLeft" align="right" valign="top">virtual int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a09ffdad22d90db55c78774c75cbac711">getWidth</a> ()=0</td></tr>
<tr class="separator:a09ffdad22d90db55c78774c75cbac711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5b166e5de40e49ce075fa3f2509eaa"><td class="memItemLeft" align="right" valign="top">virtual PaletteManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a5a5b166e5de40e49ce075fa3f2509eaa">getPaletteManager</a> ()=0</td></tr>
<tr class="separator:a5a5b166e5de40e49ce075fa3f2509eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd1ca71d829f306b4b6d4cdaedcbcf7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aafd1ca71d829f306b4b6d4cdaedcbcf7">copyRectToScreen</a> (const void *buf, int pitch, int x, int y, int w, int h)=0</td></tr>
<tr class="separator:aafd1ca71d829f306b4b6d4cdaedcbcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a4f05596bd55c887e35a34937939c5"><td class="memItemLeft" align="right" valign="top">virtual Graphics::Surface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a56a4f05596bd55c887e35a34937939c5">lockScreen</a> ()=0</td></tr>
<tr class="separator:a56a4f05596bd55c887e35a34937939c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87138a721368bed7abde76c0f24c880"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ab87138a721368bed7abde76c0f24c880">unlockScreen</a> ()=0</td></tr>
<tr class="separator:ab87138a721368bed7abde76c0f24c880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12df877f26c4db662aece81be9bf833"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#af12df877f26c4db662aece81be9bf833">fillScreen</a> (uint32 col)=0</td></tr>
<tr class="separator:af12df877f26c4db662aece81be9bf833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6983105f21ef8bdf828a51e4cec4cfe8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a6983105f21ef8bdf828a51e4cec4cfe8">updateScreen</a> ()=0</td></tr>
<tr class="separator:a6983105f21ef8bdf828a51e4cec4cfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9a92117c13ae543fcaa6769a31614d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a2f9a92117c13ae543fcaa6769a31614d">setShakePos</a> (int shakeXOffset, int shakeYOffset)=0</td></tr>
<tr class="separator:a2f9a92117c13ae543fcaa6769a31614d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337901711715fd99610be213a9e0dab0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a337901711715fd99610be213a9e0dab0">setFocusRectangle</a> (const <a class="el" href="struct_common_1_1_rect.html">Common::Rect</a> &amp;rect)</td></tr>
<tr class="separator:a337901711715fd99610be213a9e0dab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6676d67905f65114a3e95f6b45227b67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a6676d67905f65114a3e95f6b45227b67">clearFocusRectangle</a> ()</td></tr>
<tr class="separator:a6676d67905f65114a3e95f6b45227b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mutex handling</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0abbdc4c7ee634380e47dbe376f9e71a"></a>Historically, the <a class="el" href="class_o_system.html">OSystem</a> API used to have a method which allowed creating threads. Hence mutex support was needed for thread syncing. To ease portability, though, we decided to remove the threading API. Instead, we now use timers (see setTimerCallback() and Common::Timer). But since those may be implemented using threads (and in fact, that's how our primary backend, the SDL one, does it on many systems), we still have to do mutex syncing in our timer callbacks. In addition, the sound mixer uses a mutex in case the backend runs it from a dedicated thread (as e.g. the SDL backend does).</p>
<p>Hence backends which do not use threads to implement the timers simply can use dummy implementations for these methods. </p>
</td></tr>
<tr class="memitem:a84988778b36b85a41c43e4f725abdc82"><td class="memItemLeft" align="right" valign="top"><a id="a84988778b36b85a41c43e4f725abdc82"></a>
typedef struct OpaqueMutex *&#160;</td><td class="memItemRight" valign="bottom"><b>MutexRef</b></td></tr>
<tr class="separator:a84988778b36b85a41c43e4f725abdc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1388ff244feacf131328f3a46b9e547a"><td class="memItemLeft" align="right" valign="top">virtual MutexRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a1388ff244feacf131328f3a46b9e547a">createMutex</a> ()=0</td></tr>
<tr class="separator:a1388ff244feacf131328f3a46b9e547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa947578a48433b04888ce975f1bcfe9b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#aa947578a48433b04888ce975f1bcfe9b">lockMutex</a> (MutexRef mutex)=0</td></tr>
<tr class="separator:aa947578a48433b04888ce975f1bcfe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e47355fde10e8cfcb4a8b0d05af84e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#ab9e47355fde10e8cfcb4a8b0d05af84e">unlockMutex</a> (MutexRef mutex)=0</td></tr>
<tr class="separator:ab9e47355fde10e8cfcb4a8b0d05af84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49791b494012e627668412a5da576a86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_system.html#a49791b494012e627668412a5da576a86">deleteMutex</a> (MutexRef mutex)=0</td></tr>
<tr class="separator:a49791b494012e627668412a5da576a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for ScummVM backends. If you want to port ScummVM to a system which is not currently covered by any of our backends, this is the place to start. ScummVM will create an instance of a subclass of this interface and use it to interact with the system.</p>
<p>In particular, a backend provides a video surface for ScummVM to draw in; methods to create timers, to handle user input events, control audio CD playback, and sound output. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab3040fae0470d961dcb5a3f6b85e8d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3040fae0470d961dcb5a3f6b85e8d44">&#9670;&nbsp;</a></span>Feature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44">OSystem::Feature</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A feature in this context means an ability of the backend which can be either on or off. Examples include:</p><ul>
<li>fullscreen mode</li>
<li>aspect ration correction</li>
<li>a virtual keyboard for text entry (on PDAs)</li>
</ul>
<p>One has to distinguish between the <em>availability</em> of a feature, which can be checked using <a class="el" href="class_o_system.html#ae7700c81f7be95f41ad2b7b75a285cd9">hasFeature()</a>, and its <em>state</em>. For example, the SDL backend <em>has</em> the kFeatureFullscreenMode, so hasFeature returns true for it. On the other hand, fullscreen mode may be active or not; this can be determined by checking the state via <a class="el" href="class_o_system.html#a03fe9288ca94a3d992d1212ef8cec311">getFeatureState()</a>. Finally, to switch between fullscreen and windowed mode, use <a class="el" href="class_o_system.html#aefa9ad64044d7775231a5bb47646dabe">setFeatureState()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a38268fda3a18b9af89c486b5fe0cb4c1"></a>kFeatureFullscreenMode&#160;</td><td class="fielddoc"><p>If supported, this feature flag can be used to switch between windowed and fullscreen mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a79f99ab355ea18b253e5f1e7923935d8"></a>kFeatureAspectRatioCorrection&#160;</td><td class="fielddoc"><p>Control aspect ratio correction. Aspect ratio correction is used to correct games running at 320x200 (i.e with an aspect ratio of 8:5), but which on their original hardware were displayed with the standard 4:3 ratio (that is, the original graphics used non-square pixels). When the backend support this, then games running at 320x200 pixels should be scaled up to 320x240 pixels. For all other resolutions, ignore this feature flag. </p><dl class="section note"><dt>Note</dt><dd>Backend implementors can find utility functions in common/scaler.h which can be used to implement aspect ratio correction. In stretch200To240() can stretch a rect, including (very fast) particular, interpolation, and works in-place. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a2a2b7fa172f929709cbfa7fe5d67dc75"></a>kFeatureFilteringMode&#160;</td><td class="fielddoc"><p>If supported this flag can be used to switch between unfiltered and filtered graphics modes. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a1e7054740414bfe948e24bafb907c6e9"></a>kFeatureStretchMode&#160;</td><td class="fielddoc"><p>Indicate if stretch modes are supported by the backend. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a22dc4fd4d1fab3654ce27d91efbcd80a"></a>kFeatureVirtualKeyboard&#160;</td><td class="fielddoc"><p>Determine whether a virtual keyboard is to be shown or not. This would mostly be implemented by backends for hand held devices, like PocketPC, Palms, Symbian phones like the P800, Zaurus, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44ace5216ddcd06da7fbd891de81d52a445"></a>kFeatureCursorPalette&#160;</td><td class="fielddoc"><p>Backends supporting this feature allow specifying a custom palette for the cursor. The custom palette is used if the feature state is set to true by the client code via <a class="el" href="class_o_system.html#aefa9ad64044d7775231a5bb47646dabe">setFeatureState()</a>.</p>
<p>It is currently used only by some Macintosh versions of Humongous Entertainment games. If the backend doesn't implement this feature then the engine switches to b/w versions of cursors. The GUI also relies on this feature for mouse cursors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44ac5e691958c1daed8f13fc4e507275f6d"></a>kFeatureOverlaySupportsAlpha&#160;</td><td class="fielddoc"><p>A backend have this feature if its overlay pixel format has an alpha channel which offers at least 3-4 bits of accuracy (as opposed to just a single alpha bit).</p>
<p>This feature has no associated state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a09f5f6a88e5e05c355de6ca0be7a80a1"></a>kFeatureIconifyWindow&#160;</td><td class="fielddoc"><p>Client code can set the state of this feature to true in order to iconify the application window. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a16ef4993243f8e9f065aeeb86e8077ea"></a>kFeatureDisplayLogFile&#160;</td><td class="fielddoc"><p>The presence of this feature indicates whether the <a class="el" href="class_o_system.html#ae04e49df91bbab6c4ad34e3c2ba52b33">displayLogFile()</a> call is supported.</p>
<p>This feature has no associated state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a1e13ae52f03883db0b14bd3934c63f56"></a>kFeatureClipboardSupport&#160;</td><td class="fielddoc"><p>The presence of this feature indicates whether the system clipboard is available. If this feature is not present, the <a class="el" href="class_o_system.html#abb4708db58c3e0b2d363b1b417752951">hasTextInClipboard()</a>, <a class="el" href="class_o_system.html#a5872a0daeae7b00a721cf894e8cf280a">getTextFromClipboard()</a> and <a class="el" href="class_o_system.html#ac8012946b2e61b9f92100f686f035391">setTextInClipboard()</a> calls can still be used, however it should not be used in scenarios where the user is expected to copy data outside of the application.</p>
<p>This feature has no associated state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a83c50fc0aba00939f42af323ae2ba9ad"></a>kFeatureOpenUrl&#160;</td><td class="fielddoc"><p>The presence of this feature indicates whether the <a class="el" href="class_o_system.html#a5f77b6796f4990c1b3791f800ba789b7">openUrl()</a> call is supported.</p>
<p>This feature has no associated state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a32d7ab5a779bcb3a7d4140a624299982"></a>kFeatureOnScreenControl&#160;</td><td class="fielddoc"><p>show on-screen control </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a871a467bcf76d80930f9393678f1723c"></a>kFeatureTouchpadMode&#160;</td><td class="fielddoc"><p>mouse emulation mode </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a83bfab7d13c24b36c2975b7b407c0c68"></a>kFeatureSwapMenuAndBackButtons&#160;</td><td class="fielddoc"><p>swap menu and back buttons </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44aa00e1d25107b008db761b746807cec46"></a>kFeatureKbdMouseSpeed&#160;</td><td class="fielddoc"><p>keyboard mouse and joystick mouse speed </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a8917d1d89a9c235a1ae5eabb064da27a"></a>kFeatureJoystickDeadzone&#160;</td><td class="fielddoc"><p>change analog joystick deadzone </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44ac441833f0cf9b43ca47fe05b777128d8"></a>kFeatureShader&#160;</td><td class="fielddoc"><p>shaders </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a6e86a84941b00145e3a6672cc01d9f0a"></a>kFeatureSystemBrowserDialog&#160;</td><td class="fielddoc"><p>Supports for using the native system file browser dialog through the DialogManager. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3040fae0470d961dcb5a3f6b85e8d44a74478943d905f49c18fc06f77871a97c"></a>kFeatureNoQuit&#160;</td><td class="fielddoc"><p>For platforms that should not have a Quit button </p>
</td></tr>
</table>

</div>
</div>
<a id="a48fc8170ee88c60da61b98df8ceb159c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fc8170ee88c60da61b98df8ceb159c">&#9670;&nbsp;</a></span>TransactionError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159c">OSystem::TransactionError</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type is able to save the different errors which can happen while changing GFX config values inside GFX transactions.</p>
<p>endGFXTransaction returns a ORed combination of the '*Failed' values if any problem occures, on success 0.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a01ac3bef878805f47afea75769010e52">endGFXTransaction</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a48fc8170ee88c60da61b98df8ceb159ca66fa9aad355638a74399dc4c3bfb8ac4"></a>kTransactionSuccess&#160;</td><td class="fielddoc"><p>Everything fine (use EQUAL check for this one!) </p>
</td></tr>
<tr><td class="fieldname"><a id="a48fc8170ee88c60da61b98df8ceb159ca63716f7d521a43fbe27c50832eb00dce"></a>kTransactionAspectRatioFailed&#160;</td><td class="fielddoc"><p>Failed switching aspect ratio correction mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a48fc8170ee88c60da61b98df8ceb159caa4b9c084a757f5b203ca709a0f614752"></a>kTransactionFullscreenFailed&#160;</td><td class="fielddoc"><p>Failed switching fullscreen mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a48fc8170ee88c60da61b98df8ceb159ca28799b1e6ddcbb2f2d0cc34122bef264"></a>kTransactionModeSwitchFailed&#160;</td><td class="fielddoc"><p>Failed switching the GFX graphics mode (setGraphicsMode) </p>
</td></tr>
<tr><td class="fieldname"><a id="a48fc8170ee88c60da61b98df8ceb159cac8a04ee3b1bef026790377fe79e79839"></a>kTransactionSizeChangeFailed&#160;</td><td class="fielddoc"><p>Failed switching the screen dimensions (initSize) </p>
</td></tr>
<tr><td class="fieldname"><a id="a48fc8170ee88c60da61b98df8ceb159ca7a40f191e89d29236bcea4c10efc003a"></a>kTransactionFormatNotSupported&#160;</td><td class="fielddoc"><p>Failed setting the color format </p>
</td></tr>
<tr><td class="fieldname"><a id="a48fc8170ee88c60da61b98df8ceb159ca6d79fe85fb37a1856e950cb2c4f155b1"></a>kTransactionFilteringFailed&#160;</td><td class="fielddoc"><p>Failed setting the filtering mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a48fc8170ee88c60da61b98df8ceb159ca00239d2e06d1e7f765ea82b38e61df95"></a>kTransactionStretchModeSwitchFailed&#160;</td><td class="fielddoc"><p>Failed setting the stretch mode </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a365ed21b6c63b30335a3dae4086325c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365ed21b6c63b30335a3dae4086325c8">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSystem::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destoy this <a class="el" href="class_o_system.html">OSystem</a> instance. </p>

</div>
</div>
<a id="a6ed174516272a646d22ababf78093134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed174516272a646d22ababf78093134">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following method should be called once, after g_system is created. </p>

</div>
</div>
<a id="a3e51e2c96b42377b7f18a2b603b8bd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e51e2c96b42377b7f18a2b603b8bd96">&#9670;&nbsp;</a></span>initBackend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::initBackend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following method is called once, from main.cpp, after all config data (including command line params etc.) are fully loaded.</p>
<dl class="section note"><dt>Note</dt><dd>Subclasses should always invoke the implementation of their parent class. They should do so near the end of their own implementation. </dd></dl>

</div>
</div>
<a id="a9a339d637d45a8c6723840d4a725acb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a339d637d45a8c6723840d4a725acb7">&#9670;&nbsp;</a></span>backendInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OSystem::backendInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return false if <a class="el" href="class_o_system.html#a3e51e2c96b42377b7f18a2b603b8bd96">initBackend()</a> has not yet been called and true otherwise. Some functionalities such as mutexes cannot be used until the backend is initialized. </p>

</div>
</div>
<a id="a5df641f992e264799bca4e668b55a874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df641f992e264799bca4e668b55a874">&#9670;&nbsp;</a></span>engineInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::engineInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows the backend to perform engine specific init. Called just before the engine is run. </p>

</div>
</div>
<a id="a5bf21ec8b60e1389428b3b5cc2a4bcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf21ec8b60e1389428b3b5cc2a4bcbe">&#9670;&nbsp;</a></span>engineDone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::engineDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows the backend to perform engine specific de-init. Called after the engine finishes. </p>

</div>
</div>
<a id="ae7700c81f7be95f41ad2b7b75a285cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7700c81f7be95f41ad2b7b75a285cd9">&#9670;&nbsp;</a></span>hasFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::hasFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine whether the backend supports the specified feature. </p>

</div>
</div>
<a id="aefa9ad64044d7775231a5bb47646dabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa9ad64044d7775231a5bb47646dabe">&#9670;&nbsp;</a></span>setFeatureState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::setFeatureState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>En-/disable the specified feature. For example, this may be used to enable fullscreen mode, or to deactivate aspect correction, etc. </p>

</div>
</div>
<a id="a03fe9288ca94a3d992d1212ef8cec311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fe9288ca94a3d992d1212ef8cec311">&#9670;&nbsp;</a></span>getFeatureState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::getFeatureState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the state of the specified feature. For example, test whether fullscreen mode is active or not. </p>

</div>
</div>
<a id="a0dc1fa028b649304870d3b1c3085602c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc1fa028b649304870d3b1c3085602c">&#9670;&nbsp;</a></span>getSupportedGraphicsModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_o_system_1_1_graphics_mode.html">GraphicsMode</a>* OSystem::getSupportedGraphicsModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a list of all graphics modes supported by this backend. This can be both video modes as well as graphic filters/scalers; it is completely up to the backend maintainer to decide what is appropriate here and what not. The list is terminated by an all-zero entry. </p><dl class="section return"><dt>Returns</dt><dd>a list of supported graphics modes </dd></dl>

</div>
</div>
<a id="afa94ee82b01397e91fd6c30fe35069df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa94ee82b01397e91fd6c30fe35069df">&#9670;&nbsp;</a></span>getDefaultGraphicsMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getDefaultGraphicsMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ID of the 'default' graphics mode. What exactly this means is up to the backend. This mode is set by the client code when no user overrides are present (i.e. if no custom graphics mode is selected via the command line or a config file).</p>
<dl class="section return"><dt>Returns</dt><dd>the ID of the 'default' graphics mode </dd></dl>

</div>
</div>
<a id="aff49759635422c63cc49b224668ba971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff49759635422c63cc49b224668ba971">&#9670;&nbsp;</a></span>setGraphicsMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::setGraphicsMode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switch to the specified graphics mode. If switching to the new mode failed, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the ID of the new graphics mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the switch was successful, false otherwise </dd></dl>

</div>
</div>
<a id="ade71cd6f36f9c795ffc738f1dd5f1ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade71cd6f36f9c795ffc738f1dd5f1ff1">&#9670;&nbsp;</a></span>setGraphicsMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSystem::setGraphicsMode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch to the graphics mode with the given name. If 'name' is unknown, or if switching to the new mode failed, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the new graphics mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the switch was successful, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is implemented via the <a class="el" href="class_o_system.html#aff49759635422c63cc49b224668ba971">setGraphicsMode(int)</a> method, as well as <a class="el" href="class_o_system.html#a0dc1fa028b649304870d3b1c3085602c">getSupportedGraphicsModes()</a> and <a class="el" href="class_o_system.html#afa94ee82b01397e91fd6c30fe35069df">getDefaultGraphicsMode()</a>. In particular, backends do not have to overload this! </dd></dl>

</div>
</div>
<a id="a1ac9f23d6481dcab24dc0ced883d8674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac9f23d6481dcab24dc0ced883d8674">&#9670;&nbsp;</a></span>getGraphicsMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getGraphicsMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine which graphics mode is currently active. </p><dl class="section return"><dt>Returns</dt><dd>the ID of the active graphics mode </dd></dl>

</div>
</div>
<a id="a80a1e6c09495e5d71d6b911f30a47d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a1e6c09495e5d71d6b911f30a47d0d">&#9670;&nbsp;</a></span>resetGraphicsScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::resetGraphicsScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the graphics scale factor to x1. Games with large screen sizes reset the scale to x1 so the screen will not be too big when starting the game. </p>

</div>
</div>
<a id="a84ed216d0fa410c8a97f4c96adb87721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ed216d0fa410c8a97f4c96adb87721">&#9670;&nbsp;</a></span>getSupportedShaders()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_o_system_1_1_graphics_mode.html">GraphicsMode</a>* OSystem::getSupportedShaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a list of all hardware shaders supported by this backend. This can be only hardware shaders. it is completely up to the backend maintainer to decide what is appropriate here and what not. The list is terminated by an all-zero entry. </p><dl class="section return"><dt>Returns</dt><dd>a list of supported shaders </dd></dl>

</div>
</div>
<a id="adf9b2ad0d7a10c74bdc57e0732471b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9b2ad0d7a10c74bdc57e0732471b3a">&#9670;&nbsp;</a></span>getDefaultShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getDefaultShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ID of the 'default' shader mode. What exactly this means is up to the backend. This mode is set by the client code when no user overrides are present (i.e. if no custom shader mode is selected via the command line or a config file).</p>
<dl class="section return"><dt>Returns</dt><dd>the ID of the 'default' shader mode </dd></dl>

</div>
</div>
<a id="a3f4a7110c7ac5e91efb8f9ccf918e6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4a7110c7ac5e91efb8f9ccf918e6c9">&#9670;&nbsp;</a></span>setShader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::setShader </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switch to the specified shader mode. If switching to the new mode failed, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the ID of the new shader mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the switch was successful, false otherwise </dd></dl>

</div>
</div>
<a id="a64e59b53635de89a69d8f28a91265039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e59b53635de89a69d8f28a91265039">&#9670;&nbsp;</a></span>setShader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSystem::setShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch to the shader mode with the given name. If 'name' is unknown, or if switching to the new mode failed, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the new shader mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the switch was successful, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is implemented via the <a class="el" href="class_o_system.html#a3f4a7110c7ac5e91efb8f9ccf918e6c9">setShader(int)</a> method, as well as <a class="el" href="class_o_system.html#a84ed216d0fa410c8a97f4c96adb87721">getSupportedShaders()</a> and <a class="el" href="class_o_system.html#adf9b2ad0d7a10c74bdc57e0732471b3a">getDefaultShader()</a>. In particular, backends do not have to overload this! </dd></dl>

</div>
</div>
<a id="abb60de0651a38b168cf10d7be7f0f12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb60de0651a38b168cf10d7be7f0f12a">&#9670;&nbsp;</a></span>getShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine which shader is currently active. </p><dl class="section return"><dt>Returns</dt><dd>the ID of the active shader </dd></dl>

</div>
</div>
<a id="a26ff83a077aea8010365cadd71e069ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ff83a077aea8010365cadd71e069ff">&#9670;&nbsp;</a></span>getSupportedStretchModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_o_system_1_1_graphics_mode.html">GraphicsMode</a>* OSystem::getSupportedStretchModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a list of all stretch modes supported by this backend. It is completely up to the backend maintainer to decide what is appropriate here and what not. The list is terminated by an all-zero entry. </p><dl class="section return"><dt>Returns</dt><dd>a list of supported stretch modes </dd></dl>

</div>
</div>
<a id="a30fb4d311447dbb3275fd749c8a4a872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fb4d311447dbb3275fd749c8a4a872">&#9670;&nbsp;</a></span>getDefaultStretchMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getDefaultStretchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ID of the 'default' stretch mode. What exactly this means is up to the backend. This mode is set by the client code when no user overrides are present (i.e. if no custom stretch mode is selected via the command line or a config file).</p>
<dl class="section return"><dt>Returns</dt><dd>the ID of the 'default' graphics mode </dd></dl>

</div>
</div>
<a id="af5b29d7de9ef8eca12f102c75b71aeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b29d7de9ef8eca12f102c75b71aeb5">&#9670;&nbsp;</a></span>setStretchMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::setStretchMode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switch to the specified stretch mode. If switching to the new mode failed, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the ID of the new graphics mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the switch was successful, false otherwise </dd></dl>

</div>
</div>
<a id="afc340ea066fa6e90c29389ba30d63ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc340ea066fa6e90c29389ba30d63ac1">&#9670;&nbsp;</a></span>setStretchMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSystem::setStretchMode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch to the stretch mode with the given name. If 'name' is unknown, or if switching to the new mode failed, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the new stretch mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the switch was successful, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is implemented via the <a class="el" href="class_o_system.html#af5b29d7de9ef8eca12f102c75b71aeb5">setStretchMode(int)</a> method, as well as <a class="el" href="class_o_system.html#a26ff83a077aea8010365cadd71e069ff">getSupportedStretchModes()</a> and <a class="el" href="class_o_system.html#a30fb4d311447dbb3275fd749c8a4a872">getDefaultStretchMode()</a>. In particular, backends do not have to overload this! </dd></dl>

</div>
</div>
<a id="ac2947969d0e6bd53e2861504085f7dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2947969d0e6bd53e2861504085f7dd8">&#9670;&nbsp;</a></span>getStretchMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getStretchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine which stretch mode is currently active. </p><dl class="section return"><dt>Returns</dt><dd>the ID of the active stretch mode </dd></dl>

</div>
</div>
<a id="a8574a1d7b9925c6573c65e45b46c1ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8574a1d7b9925c6573c65e45b46c1ada">&#9670;&nbsp;</a></span>initSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::initSize </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graphics::PixelFormat *&#160;</td>
          <td class="paramname"><em>format</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the size and color format of the virtual screen. Typical sizes include:</p><ul>
<li>320x200 (e.g. for most SCUMM games, and Simon)</li>
<li>320x240 (e.g. for FM-TOWN SCUMM games)</li>
<li>640x480 (e.g. for Curse of Monkey Island)</li>
</ul>
<p>This is the resolution for which the client code generates data; this is not necessarily equal to the actual display size. For example, a backend may magnify the graphics to fit on screen (see also the <a class="el" href="struct_o_system_1_1_graphics_mode.html">GraphicsMode</a>); stretch the data to perform aspect ratio correction; or shrink it to fit on small screens (in cell phones).</p>
<p>Typical formats include: CLUT8 (e.g. 256 color, for most games) RGB555 (e.g. 16-bit color, for later SCUMM HE games) RGB565 (e.g. 16-bit color, for Urban Runner)</p>
<p>This is the pixel format for which the client code generates data; this is not necessarily equal to the hardware pixel format. For example, a backend may perform color lookup of 8-bit graphics before pushing a screen to hardware, or correct the ARGB color order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>the new virtual screen width </td></tr>
    <tr><td class="paramname">height</td><td>the new virtual screen height </td></tr>
    <tr><td class="paramname">format</td><td>the new virtual screen pixel format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d50cd90f90dc0d24cdfdfbc9af7409b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d50cd90f90dc0d24cdfdfbc9af7409b">&#9670;&nbsp;</a></span>initSizeHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::initSizeHint </td>
          <td>(</td>
          <td class="paramtype">const Graphics::ModeList &amp;&#160;</td>
          <td class="paramname"><em>modes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a list of graphics modes to the backend so it can make a decision about the best way to set up the display hardware.</p>
<p>Engines that switch between different virtual screen sizes during a game should call this function prior to any call to initSize. Engines that use only a single screen size do not need to call this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modes</td><td>the list of graphics modes the engine will probably use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b0fa3319a08ccde3a7e59efede348b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0fa3319a08ccde3a7e59efede348b0">&#9670;&nbsp;</a></span>getScreenChangeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OSystem::getScreenChangeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an int value which is changed whenever any screen parameters (like the resolution) change. That is, whenever a EVENT_SCREEN_CHANGED would be sent. You can track this value in your code to detect screen changes in case you do not have full control over the event loop(s) being used (like the GUI code).</p>
<dl class="section return"><dt>Returns</dt><dd>an integer which can be used to track screen changes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Backends which generate EVENT_SCREEN_CHANGED events MUST overload this method appropriately. </dd></dl>

</div>
</div>
<a id="a5e53c3c0d13ad5cd7b20f3ab42e71651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e53c3c0d13ad5cd7b20f3ab42e71651">&#9670;&nbsp;</a></span>beginGFXTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::beginGFXTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin a new GFX transaction, which is a sequence of GFX mode changes. The idea behind GFX transactions is to make it possible to activate several different GFX changes at once as a "batch" operation. For example, assume we are running in 320x200 with a 2x scaler (thus using 640x400 pixels in total). Now, we want to switch to 640x400 with the 1x scaler. Without transactions, we have to choose whether we want to first switch the scaler mode, or first to 640x400 mode. In either case, depending on the backend implementation, some ugliness may result. E.g. the window might briefly switch to 320x200 or 1280x800. Using transactions, this can be avoided.</p>
<dl class="section note"><dt>Note</dt><dd>Transaction support is optional, and the default implementations of the relevant methods simply do nothing. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a01ac3bef878805f47afea75769010e52">endGFXTransaction</a> </dd></dl>

</div>
</div>
<a id="a01ac3bef878805f47afea75769010e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ac3bef878805f47afea75769010e52">&#9670;&nbsp;</a></span>endGFXTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_o_system.html#a48fc8170ee88c60da61b98df8ceb159c">TransactionError</a> OSystem::endGFXTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End (and thereby commit) the current GFX transaction. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a5e53c3c0d13ad5cd7b20f3ab42e71651">beginGFXTransaction</a> </dd>
<dd>
kTransactionError </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns a ORed combination of TransactionError values or 0 on success </dd></dl>

</div>
</div>
<a id="a1e2be76e9ae3a95e4ece3732588e0ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2be76e9ae3a95e4ece3732588e0ac3">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16 OSystem::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the currently set virtual screen height. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a8574a1d7b9925c6573c65e45b46c1ada">initSize</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the currently set virtual screen height </dd></dl>

</div>
</div>
<a id="a09ffdad22d90db55c78774c75cbac711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ffdad22d90db55c78774c75cbac711">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16 OSystem::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the currently set virtual screen width. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a8574a1d7b9925c6573c65e45b46c1ada">initSize</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the currently set virtual screen width </dd></dl>

</div>
</div>
<a id="a5a5b166e5de40e49ce075fa3f2509eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5b166e5de40e49ce075fa3f2509eaa">&#9670;&nbsp;</a></span>getPaletteManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PaletteManager* OSystem::getPaletteManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the palette manager singleton. For more information, refer to the PaletteManager documentation. </p>

</div>
</div>
<a id="aafd1ca71d829f306b4b6d4cdaedcbcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd1ca71d829f306b4b6d4cdaedcbcf7">&#9670;&nbsp;</a></span>copyRectToScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::copyRectToScreen </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blit a bitmap to the virtual screen. The real screen will not immediately be updated to reflect the changes. Client code has to to call updateScreen to ensure any changes are visible to the user. This can be used to optimize drawing and reduce flicker. If the current pixel format has one byte per pixel, the graphics data uses 8 bits per pixel, using the palette specified via setPalette. If more than one byte per pixel is in use, the graphics data uses the pixel format returned by getScreenFormat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer containing the graphics data source </td></tr>
    <tr><td class="paramname">pitch</td><td>the pitch of the buffer (number of bytes in a scanline) </td></tr>
    <tr><td class="paramname">x</td><td>the x coordinate of the destination rectangle </td></tr>
    <tr><td class="paramname">y</td><td>the y coordinate of the destination rectangle </td></tr>
    <tr><td class="paramname">w</td><td>the width of the destination rectangle </td></tr>
    <tr><td class="paramname">h</td><td>the height of the destination rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The specified destination rectangle must be completly contained in the visible screen space, and must be non-empty. If not, a backend may or may not perform clipping, trigger an assert or silently corrupt memory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a6983105f21ef8bdf828a51e4cec4cfe8">updateScreen</a> </dd>
<dd>
getScreenFormat </dd></dl>

</div>
</div>
<a id="a56a4f05596bd55c887e35a34937939c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a4f05596bd55c887e35a34937939c5">&#9670;&nbsp;</a></span>lockScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Graphics::Surface* OSystem::lockScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lock the active screen framebuffer and return a Graphics::Surface representing it. The caller can then perform arbitrary graphics transformations on the framebuffer (blitting, scrolling, etc.). Must be followed by matching call to <a class="el" href="class_o_system.html#ab87138a721368bed7abde76c0f24c880">unlockScreen()</a>. Calling code should make sure to only lock the framebuffer for the briefest periods of time possible, as the whole system is potentially stalled while the lock is active. Returns 0 if an error occurred. Otherwise a surface with the pixel format described by getScreenFormat is returned.</p>
<p>The returned surface must <em>not</em> be deleted by the client code.</p>
<dl class="section see"><dt>See also</dt><dd>getScreenFormat </dd></dl>

</div>
</div>
<a id="ab87138a721368bed7abde76c0f24c880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87138a721368bed7abde76c0f24c880">&#9670;&nbsp;</a></span>unlockScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::unlockScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlock the screen framebuffer, and mark it as dirty (i.e. during the next <a class="el" href="class_o_system.html#a6983105f21ef8bdf828a51e4cec4cfe8">updateScreen()</a> call, the whole screen will be updated. </p>

</div>
</div>
<a id="af12df877f26c4db662aece81be9bf833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12df877f26c4db662aece81be9bf833">&#9670;&nbsp;</a></span>fillScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::fillScreen </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the screen with a given color value. </p>

</div>
</div>
<a id="a6983105f21ef8bdf828a51e4cec4cfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6983105f21ef8bdf828a51e4cec4cfe8">&#9670;&nbsp;</a></span>updateScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::updateScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush the whole screen, that is render the current content of the screen framebuffer to the display.</p>
<p>This method could be called very often by engines. Backends are hence supposed to only perform any redrawing if it is necessary, and otherwise return immediately. See <a href="https://wiki.scummvm.org/index.php/HOWTO-Backends#updateScreen.28.29_method">https://wiki.scummvm.org/index.php/HOWTO-Backends#updateScreen.28.29_method</a> </p>

</div>
</div>
<a id="a2f9a92117c13ae543fcaa6769a31614d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9a92117c13ae543fcaa6769a31614d">&#9670;&nbsp;</a></span>setShakePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::setShakePos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shakeXOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shakeYOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set current shake position, a feature needed for some SCUMM screen effects. The effect causes the displayed graphics to be shifted upwards by the specified (always positive) offset. The area at the bottom of the screen which is moved into view by this is filled with black. This does not cause any graphic data to be lost - that is, to restore the original view, the game engine only has to call this method again with offset equal to zero. No calls to copyRectToScreen are necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shakeXOffset</td><td>the shake x offset </td></tr>
    <tr><td class="paramname">shakeYOffset</td><td>the shake y offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is currently used in the SCUMM, QUEEN, KYRA, SCI, DREAMWEB, SUPERNOVA, TEENAGENT, TOLTECS, ULTIMA, and PETKA engines. </dd></dl>

</div>
</div>
<a id="a337901711715fd99610be213a9e0dab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337901711715fd99610be213a9e0dab0">&#9670;&nbsp;</a></span>setFocusRectangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::setFocusRectangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_common_1_1_rect.html">Common::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the area of the screen that has the focus. For example, when a character is speaking, they will have the focus. Allows for pan-and-scan style views where the backend could follow the speaking character or area of interest on the screen.</p>
<p>The backend is responsible for clipping the rectangle and deciding how best to zoom the screen to show any shape and size rectangle the engine provides.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>A rectangle on the screen to be focused on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a6676d67905f65114a3e95f6b45227b67">clearFocusRectangle</a> </dd></dl>

</div>
</div>
<a id="a6676d67905f65114a3e95f6b45227b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6676d67905f65114a3e95f6b45227b67">&#9670;&nbsp;</a></span>clearFocusRectangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::clearFocusRectangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the focus set by a call to <a class="el" href="class_o_system.html#a337901711715fd99610be213a9e0dab0">setFocusRectangle()</a>. This allows the engine to clear the focus during times when no particular area of the screen has the focus. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a337901711715fd99610be213a9e0dab0">setFocusRectangle</a> </dd></dl>

</div>
</div>
<a id="a7e87827f0a7cd665c569d6642a9da9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e87827f0a7cd665c569d6642a9da9e1">&#9670;&nbsp;</a></span>showOverlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::showOverlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Activate the overlay mode. </p>

</div>
</div>
<a id="a1e381ce4d94579030a9d834dc514498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e381ce4d94579030a9d834dc514498c">&#9670;&nbsp;</a></span>hideOverlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::hideOverlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deactivate the overlay mode. </p>

</div>
</div>
<a id="a61e96d22ca114352872ac28a7105c465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e96d22ca114352872ac28a7105c465">&#9670;&nbsp;</a></span>getOverlayFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Graphics::PixelFormat OSystem::getOverlayFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the pixel format description of the overlay. </p><dl class="section see"><dt>See also</dt><dd>Graphics::PixelFormat </dd></dl>

</div>
</div>
<a id="a8962537874e1b9b26db0d2848c68b802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8962537874e1b9b26db0d2848c68b802">&#9670;&nbsp;</a></span>clearOverlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::clearOverlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the overlay.</p>
<p>After calling this method while the overlay mode is active, the user should be seeing only the game graphics. How this is achieved depends on how the backend implements the overlay. Either it sets all pixels of the overlay to be transparent (when alpha blending is used).</p>
<p>Or, in case of fake alpha blending, it might just put a copy of the current game graphics screen into the overlay. </p>

</div>
</div>
<a id="aee5f027431cd407947e375b7c10cb21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5f027431cd407947e375b7c10cb21c">&#9670;&nbsp;</a></span>grabOverlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::grabOverlay </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the content of the overlay into a buffer provided by the caller. This is only used to implement fake alpha blending. </p>

</div>
</div>
<a id="a5fb8dd7938c7ad39a84ada94c5f5b53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb8dd7938c7ad39a84ada94c5f5b53a">&#9670;&nbsp;</a></span>copyRectToOverlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::copyRectToOverlay </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blit a graphics buffer to the overlay. In a sense, this is the reverse of grabOverlay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer containing the graphics data source </td></tr>
    <tr><td class="paramname">pitch</td><td>the pitch of the buffer (number of bytes in a scanline) </td></tr>
    <tr><td class="paramname">x</td><td>the x coordinate of the destination rectangle </td></tr>
    <tr><td class="paramname">y</td><td>the y coordinate of the destination rectangle </td></tr>
    <tr><td class="paramname">w</td><td>the width of the destination rectangle </td></tr>
    <tr><td class="paramname">h</td><td>the height of the destination rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#aafd1ca71d829f306b4b6d4cdaedcbcf7">copyRectToScreen</a> </dd>
<dd>
<a class="el" href="class_o_system.html#aee5f027431cd407947e375b7c10cb21c">grabOverlay</a> </dd></dl>

</div>
</div>
<a id="a28ff48460f11538647ffc7d807e41923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ff48460f11538647ffc7d807e41923">&#9670;&nbsp;</a></span>getOverlayHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16 OSystem::getOverlayHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the height of the overlay. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a1e2be76e9ae3a95e4ece3732588e0ac3">getHeight</a> </dd></dl>

</div>
</div>
<a id="ab6095edde38573f40e381dd470acf4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6095edde38573f40e381dd470acf4d6">&#9670;&nbsp;</a></span>getOverlayWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16 OSystem::getOverlayWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the width of the overlay. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_o_system.html#a09ffdad22d90db55c78774c75cbac711">getWidth</a> </dd></dl>

</div>
</div>
<a id="adba65b23c102e1a3ecf177ffdde0ddc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba65b23c102e1a3ecf177ffdde0ddc1">&#9670;&nbsp;</a></span>showMouse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::showMouse </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Show or hide the mouse cursor.</p>
<p>Currently the backend is not required to immediately draw the mouse cursor on showMouse(true).</p>
<p>TODO: We might want to reconsider this fact, check Graphics::CursorManager::showMouse for some details about this.</p>
<dl class="section see"><dt>See also</dt><dd>Graphics::CursorManager::showMouse </dd></dl>

</div>
</div>
<a id="aecab84670def917107d6c1b5ca3b82c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecab84670def917107d6c1b5ca3b82c3">&#9670;&nbsp;</a></span>warpMouse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::warpMouse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move ("warp") the mouse cursor to the specified position in virtual screen coordinates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the new x position of the mouse </td></tr>
    <tr><td class="paramname">y</td><td>the new y position of the mouse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e1bbc0923c0cc7bfe2660a63a224edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1bbc0923c0cc7bfe2660a63a224edd">&#9670;&nbsp;</a></span>setMouseCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::setMouseCursor </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hotspotX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hotspotY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>keycolor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dontScale</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graphics::PixelFormat *&#160;</td>
          <td class="paramname"><em>format</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the bitmap used for drawing the cursor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the pixmap data to be used </td></tr>
    <tr><td class="paramname">w</td><td>width of the mouse cursor </td></tr>
    <tr><td class="paramname">h</td><td>height of the mouse cursor </td></tr>
    <tr><td class="paramname">hotspotX</td><td>horizontal offset from the left side to the hotspot </td></tr>
    <tr><td class="paramname">hotspotY</td><td>vertical offset from the top side to the hotspot </td></tr>
    <tr><td class="paramname">keycolor</td><td>transparency color value. This should not exceed the maximum color value of the specified format. In case it does the behavior is undefined. The backend might just error out or simply ignore the value. (The SDL backend will just assert to prevent abuse of this). </td></tr>
    <tr><td class="paramname">dontScale</td><td>Whether the cursor should never be scaled. An exception are high ppi displays, where the cursor would be too small to notice otherwise, these are allowed to scale the cursor anyway. </td></tr>
    <tr><td class="paramname">format</td><td>pointer to the pixel format which cursor graphic uses (0 means CLUT8) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba50e0cd9ba60787a50ac4d64d49a0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba50e0cd9ba60787a50ac4d64d49a0b6">&#9670;&nbsp;</a></span>setCursorPalette()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::setCursorPalette </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace the specified range of cursor the palette with new colors. The palette entries from 'start' till (start+num-1) will be replaced - so a full palette update is accomplished via start=0, num=256.</p>
<p>Backends which implement it should have kFeatureCursorPalette flag set</p>
<dl class="section see"><dt>See also</dt><dd>setPalette </dd>
<dd>
<a class="el" href="class_o_system.html#ab3040fae0470d961dcb5a3f6b85e8d44ace5216ddcd06da7fbd891de81d52a445">kFeatureCursorPalette</a> </dd></dl>

</div>
</div>
<a id="a323083759ebb539578dcc9488bbf2995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323083759ebb539578dcc9488bbf2995">&#9670;&nbsp;</a></span>getMillis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 OSystem::getMillis </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipRecord</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of milliseconds since the program was started.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipRecord</td><td>Skip recording of this value by event recorder. This could be needed particularly when we are in an on-screen GUI loop where player can pause the recording. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e05463c6a2803303a9dca2eb3beed1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e05463c6a2803303a9dca2eb3beed1e">&#9670;&nbsp;</a></span>delayMillis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::delayMillis </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>msecs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delay/sleep for the specified amount of milliseconds. </p>

</div>
</div>
<a id="a6973ec117b3fd87e22e20bd506094470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6973ec117b3fd87e22e20bd506094470">&#9670;&nbsp;</a></span>getTimeAndDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::getTimeAndDate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_time_date.html">TimeDate</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current time and date, in the local timezone. Corresponds on many systems to the combination of time() and localtime(). </p>

</div>
</div>
<a id="abb38c76beedc540c25e038e32e630bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb38c76beedc540c25e038e32e630bec">&#9670;&nbsp;</a></span>getTimerManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_timer_manager.html">Common::TimerManager</a>* OSystem::getTimerManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the timer manager singleton. For more information, refer to the TimerManager documentation. </p>

</div>
</div>
<a id="af6565e99280a20785dd0d214b16aa59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6565e99280a20785dd0d214b16aa59b">&#9670;&nbsp;</a></span>getEventManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_event_manager.html">Common::EventManager</a>* OSystem::getEventManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the event manager singleton. For more information, refer to the EventManager documentation. </p>

</div>
</div>
<a id="a0d616cd3e021300d2ff1f6f175d425a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d616cd3e021300d2ff1f6f175d425a5">&#9670;&nbsp;</a></span>getHardwareInputSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Common::HardwareInputSet* OSystem::getHardwareInputSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register hardware inputs with keymapper</p>
<dl class="section return"><dt>Returns</dt><dd>HardwareInputSet with all keys and recommended mappings</dd></dl>
<p>See keymapper documentation for further reference. </p>

</div>
</div>
<a id="af59947e12fb735f772b11272e5e8fb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59947e12fb735f772b11272e5e8fb49">&#9670;&nbsp;</a></span>getGlobalKeymaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_array.html">Common::KeymapArray</a> OSystem::getGlobalKeymaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a platform-specific global keymap</p>
<dl class="section return"><dt>Returns</dt><dd>Keymap with actions appropriate for the platform</dd></dl>
<p>The caller will use and delete the return object.</p>
<p>See keymapper documentation for further reference. </p>

</div>
</div>
<a id="ab88d7fd17b7f1e6947e16eb5f9e97353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88d7fd17b7f1e6947e16eb5f9e97353">&#9670;&nbsp;</a></span>getKeymapperDefaultBindings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Common::KeymapperDefaultBindings* OSystem::getKeymapperDefaultBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return platform-specific default keybindings</p>
<dl class="section return"><dt>Returns</dt><dd>KeymapperDefaultBindings populated with keybindings</dd></dl>
<p>See keymapper documentation for further reference. </p>

</div>
</div>
<a id="a1388ff244feacf131328f3a46b9e547a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1388ff244feacf131328f3a46b9e547a">&#9670;&nbsp;</a></span>createMutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MutexRef OSystem::createMutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new mutex. </p><dl class="section return"><dt>Returns</dt><dd>the newly created mutex, or 0 if an error occurred. </dd></dl>

</div>
</div>
<a id="aa947578a48433b04888ce975f1bcfe9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa947578a48433b04888ce975f1bcfe9b">&#9670;&nbsp;</a></span>lockMutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::lockMutex </td>
          <td>(</td>
          <td class="paramtype">MutexRef&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lock the given mutex.</p>
<dl class="section note"><dt>Note</dt><dd>ScummVM code assumes that the mutex implementation supports recursive locking. That is, a thread may lock a mutex twice w/o deadlocking. In case of a multilock, the mutex has to be unlocked as many times as it was locked befored it really becomes unlocked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9e47355fde10e8cfcb4a8b0d05af84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e47355fde10e8cfcb4a8b0d05af84e">&#9670;&nbsp;</a></span>unlockMutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::unlockMutex </td>
          <td>(</td>
          <td class="paramtype">MutexRef&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlock the given mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to unlock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49791b494012e627668412a5da576a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49791b494012e627668412a5da576a86">&#9670;&nbsp;</a></span>deleteMutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::deleteMutex </td>
          <td>(</td>
          <td class="paramtype">MutexRef&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete the given mutex. Make sure the mutex is unlocked before you delete it. If you delete a locked mutex, the behavior is undefined, in particular, your program may crash. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d4e32ada84b5cac226991cac3ac4541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4e32ada84b5cac226991cac3ac4541">&#9670;&nbsp;</a></span>getMixer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Audio::Mixer* OSystem::getMixer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the audio mixer. For more information, refer to the Audio::Mixer documentation. </p>

</div>
</div>
<a id="a36d8e52c3aab3c60dd37ecb57f859c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d8e52c3aab3c60dd37ecb57f859c6f">&#9670;&nbsp;</a></span>getAudioCDManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AudioCDManager* OSystem::getAudioCDManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the audio cd manager. For more information, refer to the AudioCDManager documentation. </p>

</div>
</div>
<a id="af2b69fefdd3500f504bd6923ea0905b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b69fefdd3500f504bd6923ea0905b5">&#9670;&nbsp;</a></span>quit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::quit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quit (exit) the application. </p>

</div>
</div>
<a id="a01edf361e28bb969fb8673e218c3cd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01edf361e28bb969fb8673e218c3cd59">&#9670;&nbsp;</a></span>fatalError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::fatalError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signals that a fatal error inside the client code has happened.</p>
<p>This should quit the application. </p>

</div>
</div>
<a id="acaeb6b4d0dc2ad83b564357e9cf001fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeb6b4d0dc2ad83b564357e9cf001fb">&#9670;&nbsp;</a></span>setWindowCaption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::setWindowCaption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>caption</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a window caption or any other comparable status display to the given value. The caption must be a pure ISO LATIN 1 string. Passing a string with a different encoding may lead to unexpected behavior, even crashes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caption</td><td>the window caption to use, as an ISO LATIN 1 string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6d4c02a92b9bc4b9e8f8bc5ee3d0234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d4c02a92b9bc4b9e8f8bc5ee3d0234">&#9670;&nbsp;</a></span>displayMessageOnOSD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::displayMessageOnOSD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_u32_string.html">Common::U32String</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Display a message in an 'on screen display'. That is, display it in a fashion where it is visible on or near the screen (e.g. in a transparent rectangle over the regular screen content; or in a message box beneath it; etc.).</p>
<p>The message is expected to be provided in the current TranslationManager charset.</p>
<dl class="section note"><dt>Note</dt><dd>There is a default implementation in BaseBackend which uses a TimedMessageDialog to display the message. Hence implementing this is optional.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message to display on screen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e25f196f210f0ff0503e41610d52d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e25f196f210f0ff0503e41610d52d00">&#9670;&nbsp;</a></span>displayActivityIconOnOSD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::displayActivityIconOnOSD </td>
          <td>(</td>
          <td class="paramtype">const Graphics::Surface *&#160;</td>
          <td class="paramname"><em>icon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Display an icon indicating background activity</p>
<p>The icon is displayed in an 'on screen display'. It is visible above the regular screen content or near it.</p>
<p>The caller keeps ownership of the icon. It is acceptable to free the surface just after the call.</p>
<p>There is no preferred pixel format for the icon. The backend should convert its copy of the icon to an appropriate format.</p>
<p>The caller must call this method again with a null pointer as a parameter to indicate the icon should no longer be displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">icon</td><td>the icon to display on screen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8d8463193d5e21efcefdd869c408f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d8463193d5e21efcefdd869c408f66">&#9670;&nbsp;</a></span>getSavefileManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_save_file_manager.html">Common::SaveFileManager</a>* OSystem::getSavefileManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the SaveFileManager, used to store and load savestates and other modifiable persistent game data. For more information, refer to the SaveFileManager documentation. </p>

</div>
</div>
<a id="a6d25f4c9f5aa7f786eaf1be0bb01256c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d25f4c9f5aa7f786eaf1be0bb01256c">&#9670;&nbsp;</a></span>getFilesystemFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FilesystemFactory* OSystem::getFilesystemFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the FilesystemFactory object, depending on the current architecture.</p>
<dl class="section return"><dt>Returns</dt><dd>the FSNode factory for the current architecture </dd></dl>

</div>
</div>
<a id="a3499c8f9d327006a82fc8685a49f2996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3499c8f9d327006a82fc8685a49f2996">&#9670;&nbsp;</a></span>addSysArchivesToSearchSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::addSysArchivesToSearchSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_common_1_1_search_set.html">Common::SearchSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add system specific <a class="el" href="class_common_1_1_archive.html">Common::Archive</a> objects to the given SearchSet. E.g. on Unix the dir corresponding to DATA_PATH (if set), or on Mac OS X the 'Resource' dir in the app bundle.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Come up with a better name. This one sucks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the SearchSet to which the system specific dirs, if any, are added </td></tr>
    <tr><td class="paramname">priority</td><td>the priority with which those dirs are added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd885a1f7449639fa8dad730b147d7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd885a1f7449639fa8dad730b147d7e7">&#9670;&nbsp;</a></span>createConfigReadStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_seekable_read_stream.html">Common::SeekableReadStream</a>* OSystem::createConfigReadStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the default config file for reading, by returning a suitable ReadStream instance. It is the callers responsiblity to delete the stream after use. </p>

</div>
</div>
<a id="ab03400a28f21de0ec695367f8e9161e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03400a28f21de0ec695367f8e9161e7">&#9670;&nbsp;</a></span>createConfigWriteStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_write_stream.html">Common::WriteStream</a>* OSystem::createConfigWriteStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the default config file for writing, by returning a suitable WriteStream instance. It is the callers responsiblity to delete the stream after use.</p>
<p>May return 0 to indicate that writing to config file is not possible. </p>

</div>
</div>
<a id="a68d7188a18abfc05cf31e5eb3d03c521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d7188a18abfc05cf31e5eb3d03c521">&#9670;&nbsp;</a></span>getDefaultConfigFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_string.html">Common::String</a> OSystem::getDefaultConfigFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the default file name (or even path) where the user configuration of ScummVM will be saved. Note that not all ports may use this. </p>

</div>
</div>
<a id="a8ae6ac8f980d2c2640d8a3cbe22a5ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae6ac8f980d2c2640d8a3cbe22a5ae4">&#9670;&nbsp;</a></span>logMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSystem::logMessage </td>
          <td>(</td>
          <td class="paramtype">LogMessageType::Type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Logs a given message.</p>
<p>It is up to the backend where to log the different messages. The backend should aim at using a non-buffered output for it so that no log data is lost in case of a crash.</p>
<p>The default implementation outputs them on stdout/stderr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of the message </td></tr>
    <tr><td class="paramname">message</td><td>the message itself </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae04e49df91bbab6c4ad34e3c2ba52b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04e49df91bbab6c4ad34e3c2ba52b33">&#9670;&nbsp;</a></span>displayLogFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::displayLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the log file in a way that allows the user to review it, and possibly email it (or parts of it) to the ScummVM team, e.g. as part of a bug report.</p>
<p>On a desktop operating system, this would typically launch some kind of (external) text editor / viewer. On a phone, it might also cause a context switch to another application. Finally, on some ports, it might not be supported at all, and so do nothing.</p>
<p>The kFeatureDisplayLogFile feature flag can be used to test whether this call has been implemented by the active backend.</p>
<dl class="section return"><dt>Returns</dt><dd>true if all seems to have gone fine, false if an error occurred</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An error could mean that the log file did not exist, or the editor could not launch. However, a return value of true does not guarantee that the user actually will see the log file.</dd>
<dd>
It is up to the backend to ensure that the system is in a state that allows the user to actually see the displayed log files. This might for example require leaving fullscreen mode. </dd></dl>

</div>
</div>
<a id="abb4708db58c3e0b2d363b1b417752951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4708db58c3e0b2d363b1b417752951">&#9670;&nbsp;</a></span>hasTextInClipboard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::hasTextInClipboard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether there is text available in the clipboard.</p>
<p>The kFeatureClipboardSupport feature flag can be used to test whether this call has been implemented by the active backend.</p>
<dl class="section return"><dt>Returns</dt><dd>true if there is text in the clipboard, false otherwise </dd></dl>

</div>
</div>
<a id="a5872a0daeae7b00a721cf894e8cf280a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5872a0daeae7b00a721cf894e8cf280a">&#9670;&nbsp;</a></span>getTextFromClipboard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_u32_string.html">Common::U32String</a> OSystem::getTextFromClipboard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns clipboard contents as a String.</p>
<p>The kFeatureClipboardSupport feature flag can be used to test whether this call has been implemented by the active backend.</p>
<dl class="section return"><dt>Returns</dt><dd>clipboard contents ("" if <a class="el" href="class_o_system.html#abb4708db58c3e0b2d363b1b417752951">hasTextInClipboard()</a> == false) </dd></dl>

</div>
</div>
<a id="ac8012946b2e61b9f92100f686f035391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8012946b2e61b9f92100f686f035391">&#9670;&nbsp;</a></span>setTextInClipboard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::setTextInClipboard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_u32_string.html">Common::U32String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the content of the clipboard to the given string.</p>
<p>The kFeatureClipboardSupport feature flag can be used to test whether this call has been implemented by the active backend.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the text was properly set in the clipboard, false otherwise </dd></dl>

</div>
</div>
<a id="a5f77b6796f4990c1b3791f800ba789b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f77b6796f4990c1b3791f800ba789b7">&#9670;&nbsp;</a></span>openUrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::openUrl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_string.html">Common::String</a> &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the given Url in the default browser (if available on the target system).</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is up to the backend to ensure that the system is in a state that allows the user to actually see the web page. This might for example require leaving fullscreen mode.</dd></dl>
<p>url the URL to open </p>

</div>
</div>
<a id="a44f63139426222890268fb5fe71c1b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f63139426222890268fb5fe71c1b47">&#9670;&nbsp;</a></span>getSystemLanguage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_string.html">Common::String</a> OSystem::getSystemLanguage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the locale of the system.</p>
<p>This returns the currently set up locale of the system, on which ScummVM is run.</p>
<p>The format of the locale is language_country. These should match the POSIX locale values.</p>
<p>For information about POSIX locales read here: <a href="http://en.wikipedia.org/wiki/Locale#POSIX-type_platforms">http://en.wikipedia.org/wiki/Locale#POSIX-type_platforms</a></p>
<p>The default implementation returns "en_US".</p>
<dl class="section return"><dt>Returns</dt><dd>locale of the system </dd></dl>

</div>
</div>
<a id="a8958d2ea676f43809ed767543ed3d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8958d2ea676f43809ed767543ed3d84c">&#9670;&nbsp;</a></span>isConnectionLimited()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OSystem::isConnectionLimited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether connection's limited (if available on the target system).</p>
<p>Returns true if connection seems limited. </p>

</div>
</div>
<a id="ac97358efae164cff487cb67298d12a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97358efae164cff487cb67298d12a9c">&#9670;&nbsp;</a></span>convertEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* OSystem::convertEncoding </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allows derived classes to implement encoding conversion using platform specific API. This method shouldn't be called directly. Use <a class="el" href="class_common_1_1_encoding.html">Common::Encoding</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>Encoding to convert the string to </td></tr>
    <tr><td class="paramname">from</td><td>Encoding to convert the string from </td></tr>
    <tr><td class="paramname">string</td><td>The string that should be converted </td></tr>
    <tr><td class="paramname">length</td><td>Size of the string in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted string, which must be freed by the caller (using free() and not delete[]), or nullptr if the conversion isn't possible. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a49364817fe70fbb97a06667c1f467afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49364817fe70fbb97a06667c1f467afc">&#9670;&nbsp;</a></span>_audiocdManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AudioCDManager* OSystem::_audiocdManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>No default value is provided for _audiocdManager by <a class="el" href="class_o_system.html">OSystem</a>. However, BaseBackend::initBackend() does set a default value if none has been set before.</p>
<dl class="section note"><dt>Note</dt><dd>_audiocdManager is deleted by the <a class="el" href="class_o_system.html">OSystem</a> destructor. </dd></dl>

</div>
</div>
<a id="ad4c080fafdc4f99c3d1a465b5266fbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c080fafdc4f99c3d1a465b5266fbec">&#9670;&nbsp;</a></span>_eventManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_event_manager.html">Common::EventManager</a>* OSystem::_eventManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>No default value is provided for _eventManager by <a class="el" href="class_o_system.html">OSystem</a>. However, EventsBaseBackend::initBackend() does set a default value if none has been set before.</p>
<dl class="section note"><dt>Note</dt><dd>_eventManager is deleted by the <a class="el" href="class_o_system.html">OSystem</a> destructor. </dd></dl>

</div>
</div>
<a id="aeb7f5d775e24a17dcdffa896e9131bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7f5d775e24a17dcdffa896e9131bc5">&#9670;&nbsp;</a></span>_timerManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_timer_manager.html">Common::TimerManager</a>* OSystem::_timerManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>No default value is provided for _timerManager by <a class="el" href="class_o_system.html">OSystem</a>.</p>
<dl class="section note"><dt>Note</dt><dd>_timerManager is deleted by the <a class="el" href="class_o_system.html">OSystem</a> destructor. </dd></dl>

</div>
</div>
<a id="ae88bb97da5abfc76d877eb60df948367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88bb97da5abfc76d877eb60df948367">&#9670;&nbsp;</a></span>_savefileManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_save_file_manager.html">Common::SaveFileManager</a>* OSystem::_savefileManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>No default value is provided for _savefileManager by <a class="el" href="class_o_system.html">OSystem</a>.</p>
<dl class="section note"><dt>Note</dt><dd>_savefileManager is deleted by the <a class="el" href="class_o_system.html">OSystem</a> destructor. </dd></dl>

</div>
</div>
<a id="a1ad8b776858aa183be882f5f36b2d42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad8b776858aa183be882f5f36b2d42e">&#9670;&nbsp;</a></span>_fsFactory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FilesystemFactory* OSystem::_fsFactory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>No default value is provided for _fsFactory by <a class="el" href="class_o_system.html">OSystem</a>.</p>
<p>Note that _fsFactory is typically required very early on, so it usually should be set in the backends constructor or shortly thereafter, and before <a class="el" href="class_o_system.html#a3e51e2c96b42377b7f18a2b603b8bd96">initBackend()</a> is called.</p>
<dl class="section note"><dt>Note</dt><dd>_fsFactory is deleted by the <a class="el" href="class_o_system.html">OSystem</a> destructor. </dd></dl>

</div>
</div>
<a id="a370071a2580d26ef36202a05bdeddff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370071a2580d26ef36202a05bdeddff2">&#9670;&nbsp;</a></span>_clipboard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_u32_string.html">Common::U32String</a> OSystem::_clipboard</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used by the default clipboard implementation, for backends that don't implement clipboard support. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>common/<a class="el" href="system_8h_source.html">system.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
