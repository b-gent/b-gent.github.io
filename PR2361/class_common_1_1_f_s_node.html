<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="cache-control" content="max-age=86400"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ScummVM API documentation: Common::FSNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="scummvm_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ScummVM API documentation
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_common_1_1_f_s_node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_common_1_1_f_s_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Common::FSNode Class Reference<div class="ingroups"><a class="el" href="group__common.html">Common API</a> &raquo; <a class="el" href="group__common__fs.html">File system</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fs_8h_source.html">fs.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Common::FSNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_common_1_1_f_s_node.png" usemap="#Common::FSNode_map" alt=""/>
  <map id="Common::FSNode_map" name="Common::FSNode_map">
<area href="class_common_1_1_archive_member.html" alt="Common::ArchiveMember" shape="rect" coords="0,0,157,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a013d2659ae462cdd4cf59026802f47c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a013d2659ae462cdd4cf59026802f47c7">ListMode</a> { <b>kListFilesOnly</b> = 1, 
<b>kListDirectoriesOnly</b> = 2, 
<b>kListAll</b> = 3
 }</td></tr>
<tr class="separator:a013d2659ae462cdd4cf59026802f47c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e004799410e3e9aa7ea18f9ec42e030"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a5e004799410e3e9aa7ea18f9ec42e030">FSNode</a> ()</td></tr>
<tr class="separator:a5e004799410e3e9aa7ea18f9ec42e030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15564ce235aaf2cad5de43d9463ae252"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a15564ce235aaf2cad5de43d9463ae252">FSNode</a> (const <a class="el" href="class_common_1_1_string.html">String</a> &amp;path)</td></tr>
<tr class="separator:a15564ce235aaf2cad5de43d9463ae252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdd20c2da072abb2cdddc0c695ea15e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#adbdd20c2da072abb2cdddc0c695ea15e">operator&lt;</a> (const <a class="el" href="class_common_1_1_f_s_node.html">FSNode</a> &amp;node) const</td></tr>
<tr class="separator:adbdd20c2da072abb2cdddc0c695ea15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba6f3a2f99cc7a92b22a87636b15bfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a2ba6f3a2f99cc7a92b22a87636b15bfd">exists</a> () const</td></tr>
<tr class="separator:a2ba6f3a2f99cc7a92b22a87636b15bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982aca323a018e5a452dfaf3fdd2b8e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_f_s_node.html">FSNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a982aca323a018e5a452dfaf3fdd2b8e0">getChild</a> (const <a class="el" href="class_common_1_1_string.html">String</a> &amp;name) const</td></tr>
<tr class="separator:a982aca323a018e5a452dfaf3fdd2b8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c0fa529e421feb4db5fcf7a819a31a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a88c0fa529e421feb4db5fcf7a819a31a">getChildren</a> (<a class="el" href="class_common_1_1_f_s_list.html">FSList</a> &amp;fslist, <a class="el" href="class_common_1_1_f_s_node.html#a013d2659ae462cdd4cf59026802f47c7">ListMode</a> mode=kListDirectoriesOnly, bool hidden=true) const</td></tr>
<tr class="separator:a88c0fa529e421feb4db5fcf7a819a31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05fbc1b5dd1131b4dee79a79e5d05da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#ae05fbc1b5dd1131b4dee79a79e5d05da">getDisplayName</a> () const</td></tr>
<tr class="separator:ae05fbc1b5dd1131b4dee79a79e5d05da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ebbd9929ac6e03c6df23d3864f355e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a55ebbd9929ac6e03c6df23d3864f355e">getName</a> () const</td></tr>
<tr class="separator:a55ebbd9929ac6e03c6df23d3864f355e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf32e27130d3597671c3403b20bb8bd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#adf32e27130d3597671c3403b20bb8bd0">getPath</a> () const</td></tr>
<tr class="separator:adf32e27130d3597671c3403b20bb8bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827d343c9f32efe599783f76bb30bc7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_f_s_node.html">FSNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a827d343c9f32efe599783f76bb30bc7e">getParent</a> () const</td></tr>
<tr class="separator:a827d343c9f32efe599783f76bb30bc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead117f795ee6dde9400f5575c7ca0b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#aead117f795ee6dde9400f5575c7ca0b0">isDirectory</a> () const</td></tr>
<tr class="separator:aead117f795ee6dde9400f5575c7ca0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44d6eb732d8c84edf10f6bbca316994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#ad44d6eb732d8c84edf10f6bbca316994">isReadable</a> () const</td></tr>
<tr class="separator:ad44d6eb732d8c84edf10f6bbca316994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca770a96627820952de0fb3a6113910"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a7ca770a96627820952de0fb3a6113910">isWritable</a> () const</td></tr>
<tr class="separator:a7ca770a96627820952de0fb3a6113910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d658e32ca7f9194285f445a68701208"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_common_1_1_seekable_read_stream.html">SeekableReadStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a6d658e32ca7f9194285f445a68701208">createReadStream</a> () const</td></tr>
<tr class="separator:a6d658e32ca7f9194285f445a68701208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3192612cdecf8b8f4cfcb2006472cefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_write_stream.html">WriteStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#a3192612cdecf8b8f4cfcb2006472cefa">createWriteStream</a> () const</td></tr>
<tr class="separator:a3192612cdecf8b8f4cfcb2006472cefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25f4126f614ad39c767c8ba19da351b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_f_s_node.html#ae25f4126f614ad39c767c8ba19da351b">createDirectory</a> () const</td></tr>
<tr class="separator:ae25f4126f614ad39c767c8ba19da351b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a49b652c3abba48f30decc4e0fe60021e"><td class="memItemLeft" align="right" valign="top"><a id="a49b652c3abba48f30decc4e0fe60021e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>::AbstractFSNode</b></td></tr>
<tr class="separator:a49b652c3abba48f30decc4e0fe60021e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_common_1_1_f_s_node.html">FSNode</a>, short for "File System Node", provides an abstraction for file paths, allowing for portable file system browsing. This means for example, that multiple or single roots have to be supported (compare Unix with a single root, Windows with multiple roots C:, D:, ...).</p>
<p>To this end, we abstract away from paths; implementations can be based on paths (and it's left to them whether / or \ or : is the path separator :-); but it is also possible to use inodes or vrefs (MacOS 9) or anything else. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a013d2659ae462cdd4cf59026802f47c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013d2659ae462cdd4cf59026802f47c7">&#9670;&nbsp;</a></span>ListMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_common_1_1_f_s_node.html#a013d2659ae462cdd4cf59026802f47c7">Common::FSNode::ListMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to tell listDir() which kind of files to list. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5e004799410e3e9aa7ea18f9ec42e030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e004799410e3e9aa7ea18f9ec42e030">&#9670;&nbsp;</a></span>FSNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Common::FSNode::FSNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new pathless <a class="el" href="class_common_1_1_f_s_node.html">FSNode</a>. Since there's no path associated with this node, path-related operations (i.e. <a class="el" href="class_common_1_1_f_s_node.html#a2ba6f3a2f99cc7a92b22a87636b15bfd">exists()</a>, <a class="el" href="class_common_1_1_f_s_node.html#aead117f795ee6dde9400f5575c7ca0b0">isDirectory()</a>, <a class="el" href="class_common_1_1_f_s_node.html#adf32e27130d3597671c3403b20bb8bd0">getPath()</a>) will always return false or raise an assertion. </p>

</div>
</div>
<a id="a15564ce235aaf2cad5de43d9463ae252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15564ce235aaf2cad5de43d9463ae252">&#9670;&nbsp;</a></span>FSNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Common::FSNode::FSNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="class_common_1_1_f_s_node.html">FSNode</a> referring to the specified path. This is the counterpart to the path() method.</p>
<p>If path is empty or equals ".", then a node representing the "current
directory" will be created. If that is not possible (since e.g. the operating system doesn't support the concept), some other directory is used (usually the root directory). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adbdd20c2da072abb2cdddc0c695ea15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdd20c2da072abb2cdddc0c695ea15e">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Common::FSNode::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_f_s_node.html">FSNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare the name of this node to the name of another. Directories go before normal files. </p>

</div>
</div>
<a id="a2ba6f3a2f99cc7a92b22a87636b15bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba6f3a2f99cc7a92b22a87636b15bfd">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Common::FSNode::exists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the object referred by this node exists in the filesystem or not.</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the node exists, false otherwise. </dd></dl>

</div>
</div>
<a id="a982aca323a018e5a452dfaf3fdd2b8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982aca323a018e5a452dfaf3fdd2b8e0">&#9670;&nbsp;</a></span>getChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_f_s_node.html">FSNode</a> Common::FSNode::getChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new node referring to a child node of the current node, which must be a directory node (otherwise an invalid node is returned). If a child matching the name exists, a normal node for it is returned. If no child with the name exists, a node for it is still returned, but <a class="el" href="class_common_1_1_f_s_node.html#a2ba6f3a2f99cc7a92b22a87636b15bfd">exists()</a> will return 'false' for it. This node can however be used to create a new file using the <a class="el" href="class_common_1_1_f_s_node.html#a3192612cdecf8b8f4cfcb2006472cefa">createWriteStream()</a> method.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>If <a class="el" href="class_common_1_1_f_s_node.html#a3192612cdecf8b8f4cfcb2006472cefa">createWriteStream()</a> (or a hypothetical future mkdir() method) is used, this should affect what exists/isDirectory/isReadable/isWritable return for existing nodes. However, this is not the case for many existing <a class="el" href="class_common_1_1_f_s_node.html">FSNode</a> implementations. Either fix those, or document that FSNodes can become 'stale'...</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of a child of this directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node referring to the child with the given name </dd></dl>

</div>
</div>
<a id="a88c0fa529e421feb4db5fcf7a819a31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c0fa529e421feb4db5fcf7a819a31a">&#9670;&nbsp;</a></span>getChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Common::FSNode::getChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_common_1_1_f_s_list.html">FSList</a> &amp;&#160;</td>
          <td class="paramname"><em>fslist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_common_1_1_f_s_node.html#a013d2659ae462cdd4cf59026802f47c7">ListMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>kListDirectoriesOnly</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hidden</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of all child nodes of this directory node. If called on a node that does not represent a directory, false is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise (e.g. when the directory does not exist). </dd></dl>

</div>
</div>
<a id="ae05fbc1b5dd1131b4dee79a79e5d05da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05fbc1b5dd1131b4dee79a79e5d05da">&#9670;&nbsp;</a></span>getDisplayName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_string.html">String</a> Common::FSNode::getDisplayName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a human readable string for this node, usable for display (e.g. in the GUI code). Do <em>not</em> rely on it being usable for anything else, like constructing paths!</p>
<dl class="section return"><dt>Returns</dt><dd>the display name </dd></dl>

<p>Reimplemented from <a class="el" href="class_common_1_1_archive_member.html">Common::ArchiveMember</a>.</p>

</div>
</div>
<a id="a55ebbd9929ac6e03c6df23d3864f355e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ebbd9929ac6e03c6df23d3864f355e">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_string.html">String</a> Common::FSNode::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string representation of the name of the file. This can be used e.g. by detection code that relies on matching the name of a given file. But it is <em>not</em> suitable for use with fopen / <a class="el" href="class_common_1_1_file.html#a713867e79ee1316faebf21642e22f391">File::open</a>, nor should it be archived.</p>
<dl class="section return"><dt>Returns</dt><dd>the file name </dd></dl>

<p>Implements <a class="el" href="class_common_1_1_archive_member.html">Common::ArchiveMember</a>.</p>

</div>
</div>
<a id="adf32e27130d3597671c3403b20bb8bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf32e27130d3597671c3403b20bb8bd0">&#9670;&nbsp;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_string.html">String</a> Common::FSNode::getPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string representation of the file which is suitable for archiving (i.e. writing to the config file). This will usually be a 'path' (hence the name of the method), but can be anything that meets the above criterions. What a 'path' is differs greatly from system to system anyway.</p>
<dl class="section note"><dt>Note</dt><dd>Do not assume that this string contains (back)slashes or any other kind of 'path separators'.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the 'path' represented by this filesystem node </dd></dl>

</div>
</div>
<a id="a827d343c9f32efe599783f76bb30bc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827d343c9f32efe599783f76bb30bc7e">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_f_s_node.html">FSNode</a> Common::FSNode::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the parent node of this node. If this node has no parent node, then it returns a duplicate of this node. </p>

</div>
</div>
<a id="aead117f795ee6dde9400f5575c7ca0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead117f795ee6dde9400f5575c7ca0b0">&#9670;&nbsp;</a></span>isDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Common::FSNode::isDirectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the node refers to a directory or not.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Currently we assume that a node that is not a directory automatically is a file (ignoring things like symlinks or pipes). That might actually be OK... but we could still add an isFile method. Or even replace isDirectory by a getType() method that can return values like kDirNodeType, kFileNodeType, kInvalidNodeType. </dd></dl>

</div>
</div>
<a id="ad44d6eb732d8c84edf10f6bbca316994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44d6eb732d8c84edf10f6bbca316994">&#9670;&nbsp;</a></span>isReadable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Common::FSNode::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the object referred by this node can be read from or not.</p>
<p>If the node refers to a directory, readability implies being able to read and list the directory entries.</p>
<p>If the node refers to a file, readability implies being able to read the contents of the file.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the object can be read, false otherwise. </dd></dl>

</div>
</div>
<a id="a7ca770a96627820952de0fb3a6113910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca770a96627820952de0fb3a6113910">&#9670;&nbsp;</a></span>isWritable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Common::FSNode::isWritable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the object referred by this node can be written to or not.</p>
<p>If the node refers to a directory, writability implies being able to modify the directory entry (i.e. rename the directory, remove it or write files inside of it).</p>
<p>If the node refers to a file, writability implies being able to write data to the file.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the object can be written to, false otherwise. </dd></dl>

</div>
</div>
<a id="a6d658e32ca7f9194285f445a68701208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d658e32ca7f9194285f445a68701208">&#9670;&nbsp;</a></span>createReadStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_common_1_1_seekable_read_stream.html">SeekableReadStream</a>* Common::FSNode::createReadStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="class_common_1_1_seekable_read_stream.html">SeekableReadStream</a> instance corresponding to the file referred by this node. This assumes that the node actually refers to a readable file. If this is not the case, 0 is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the stream object, 0 in case of a failure </dd></dl>

<p>Implements <a class="el" href="class_common_1_1_archive_member.html">Common::ArchiveMember</a>.</p>

</div>
</div>
<a id="a3192612cdecf8b8f4cfcb2006472cefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3192612cdecf8b8f4cfcb2006472cefa">&#9670;&nbsp;</a></span>createWriteStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_write_stream.html">WriteStream</a>* Common::FSNode::createWriteStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="class_common_1_1_write_stream.html">WriteStream</a> instance corresponding to the file referred by this node. This assumes that the node actually refers to a readable file. If this is not the case, 0 is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the stream object, 0 in case of a failure </dd></dl>

</div>
</div>
<a id="ae25f4126f614ad39c767c8ba19da351b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25f4126f614ad39c767c8ba19da351b">&#9670;&nbsp;</a></span>createDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Common::FSNode::createDirectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a directory referred by this node. This assumes that this node refers to non-existing directory. If this is not the case, false is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the directory was created, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>common/<a class="el" href="fs_8h_source.html">fs.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
